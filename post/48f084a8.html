

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" href="/img/logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#f9e4eb96">
  <meta name="author" content="Ywj226">
  <meta name="keywords" content="">
  
    <meta name="description" content="本科保研期间针对于基础课程的记录，个人认为可以用到研究生毕业">
<meta property="og:type" content="article">
<meta property="og:title" content="机试复习">
<meta property="og:url" content="http://paopao0226.site/post/48f084a8.html">
<meta property="og:site_name" content="Ywj226">
<meta property="og:description" content="本科保研期间针对于基础课程的记录，个人认为可以用到研究生毕业">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210822154642276.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210822213659047.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210823235144263.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210824144744931.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210825001507160.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210824165312352.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210825001903536.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210825124328622.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210825124536399.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210825133131114.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210825221658353.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210825223455741.png">
<meta property="og:image" content="http://paopao0226.site/post/image-20210825230159042.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210826115712665.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210826131138176.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210826131645258.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210826133840327.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210826143242611.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210829182612966.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210829182619920.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210829182632294.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210829182641612.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210829182647238.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210829184136757.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210829225806186.png">
<meta property="og:image" content="http://paopao0226.site/post/image-20210829234753028.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210831151233385.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210831151327608.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210831202929031.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210831213559881.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210831222636790.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210831221029922.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210831221147080.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210831221131911.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210831230715516.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210831230647515.png">
<meta property="og:image" content="http://paopao0226.site/post/image-20210831230625539.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210831234405143.png">
<meta property="og:image" content="http://paopao0226.site/post/image-20210901000015149.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210901135552976.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210826144543958.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210826144432994.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210826150626209.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210826150820966.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210826160014477.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210826165855069.png">
<meta property="og:image" content="http://paopao0226.site/post/image-20210826172152769.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210827130138656.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210827121556326.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210827123510128.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210827130855450.png">
<meta property="og:image" content="http://paopao0226.site/post/image-20210827150150578.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210827150207137.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210827151843247.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210827164455255.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210828111300203.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210828104558147.png">
<meta property="og:image" content="http://paopao0226.site/image-20210915004217354.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210828111946980.png">
<meta property="og:image" content="http://paopao0226.site/image-20210914152204058.png">
<meta property="og:image" content="http://paopao0226.site/post/image-20210914152628226.png">
<meta property="og:image" content="http://paopao0226.site/image-20210914152609245.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210828221114654.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210828220535066.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210829133130091.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210829135504450.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210829160917625.png">
<meta property="og:image" content="http://paopao0226.site/post/image-20210829163822491.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210829163918358.png">
<meta property="og:image" content="http://paopao0226.site/post/48f084a8/image-20210829164000459.png">
<meta property="og:image" content="http://paopao0226.site/post/image-20210829165354551.png">
<meta property="article:published_time" content="2022-08-18T11:10:16.000Z">
<meta property="article:modified_time" content="2023-09-23T08:14:35.894Z">
<meta property="article:author" content="Ywj226">
<meta property="article:tag" content="机试">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://paopao0226.site/post/48f084a8/image-20210822154642276.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>机试复习 - Ywj226</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/extra_css.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"paopao0226.site","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>YWJ226</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/message/">
                <i class="iconfont icon-note"></i>
                <span>留言板</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/download/">
                <i class="iconfont icon-books"></i>
                <span>文件</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/cover2.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="机试复习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Ywj226
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-18 19:10" pubdate>
          2022年8月18日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          46k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          383 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">机试复习</h1>
            
              <p class="note note-success">
                
                  
                    本文最后更新于：几秒前
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h2 id="SF"><a href="#SF" class="headerlink" title="SF"></a>SF</h2><p>1、数组越界；2、数组开小了</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>1、特判</p>
<p>2、取l,r为端点外边</p>
<p>3、循环(l&lt;r)，使用do-while</p>
<p>4、递归调用，其中使用最后的r作为分割点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span> num[],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt;= right)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//1、这里的l和r在外围，t是中间数，left+right-1的话，在分治的时候要用r作为边界点 </span><br>    <span class="hljs-type">int</span> l = left<span class="hljs-number">-1</span>;<span class="hljs-type">int</span> r = right+<span class="hljs-number">1</span>;<span class="hljs-type">int</span> t = num[(left+right<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-comment">//2、先移动，后判断</span><br>        <span class="hljs-comment">//移动左边	</span><br>        <span class="hljs-keyword">do</span> l++; <span class="hljs-keyword">while</span>(num[l] &lt; t);<br>        <span class="hljs-comment">//移动右边</span><br>        <span class="hljs-keyword">do</span> r--; <span class="hljs-keyword">while</span>(num[r] &gt; t);<br>        <span class="hljs-comment">//3、如果没有相遇，则交换l和r</span><br>        <span class="hljs-keyword">if</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> tmp = num[l];<br>            num[l] = num[r];<br>            num[r] = tmp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//4、分治,r为分界点</span><br>    <span class="hljs-built_in">quicksort</span>(num,left,r);<br>    <span class="hljs-built_in">quicksort</span>(num,r+<span class="hljs-number">1</span>,right);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>1、特判</p>
<p>2、先对两边sort</p>
<p>3、再对两边循环，merge</p>
<p>4、如果两段中有未完成循环的接到最后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(<span class="hljs-type">int</span> num[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> m = (l+r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> tmp[r-l+<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//分治法将两端进行排序</span><br>    <span class="hljs-built_in">mergesort</span>(num,l,m);	<br>    <span class="hljs-built_in">mergesort</span>(num,m+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-comment">//双指针将两端数组进行归并</span><br>    <span class="hljs-type">int</span> i = l;<span class="hljs-type">int</span> j = m+<span class="hljs-number">1</span>;<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= m&amp;&amp;j &lt;= r)&#123;<br>        <span class="hljs-keyword">if</span>(num[i] &lt; num[j])&#123;<br>            tmp[k] = num[i];i++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            tmp[k] = num[j];j++;<br>        &#125;<br>        k++;<br>    &#125;<br>    <span class="hljs-comment">//处理一段归并完成但另一段没有的情况</span><br>    <span class="hljs-keyword">while</span>(i &lt;= m)&#123;<br>        tmp[k] = num[i];i++;k++;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j &lt;= r)&#123;<br>        tmp[k] = num[j];j++;k++;<br>    &#125;<br>    k = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//赋值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a = l;a &lt;= r;a++)&#123;<br>        num[a] = tmp[k];k++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="二分排序"><a href="#二分排序" class="headerlink" title="二分排序"></a>二分排序</h2><p>1、确定判断条件：如小于等于k的最大值</p>
<p>2、while(l&lt;r){</p>
<p>​		<strong>int m &#x3D; (l+r+1)&#x2F;2; &#x2F;&#x2F;取中点 ,如果有l&#x3D;m则需取上分界</strong></p>
<p>​		&#x2F;&#x2F;小于等于：&lt;&#x3D;</p>
<p>​		if(f[m] &lt;&#x3D; k) l &#x3D; m;	&#x2F;&#x2F;判断条件：我们需要找到<strong>最大值</strong>，因此需要尽量往右推，因为等于k的时候满足条件，所以右推的时候是l &#x3D; m，<strong>不去除m对应的点防止丢失</strong></p>
<p>​		else r &#x3D; m+1;</p>
<p>}</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">divide_right</span><span class="hljs-params">(<span class="hljs-type">int</span> num[],<span class="hljs-type">int</span> q,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-comment">//右端点的特点是在右端点的左边的所有数都满足x &lt;= q;</span><br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-comment">//在这里需要取中点上界，防止死循环</span><br>        <span class="hljs-type">int</span> m = (l+r+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//如果在右端点左边，说明x在num[m]和r之间，且可能num[m]==x;</span><br>        <span class="hljs-keyword">if</span>(num[m] &lt;= q) l = m;<br>        <span class="hljs-comment">//否则m对应的数一定不在范围里，直接跳到下一个</span><br>        <span class="hljs-keyword">else</span> r = m<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(num[l] != q)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">double</span> n;cin &gt;&gt; n;<br>    <span class="hljs-type">double</span> l = <span class="hljs-number">-10000</span>;<span class="hljs-type">double</span> r = <span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">while</span>(r-l &gt; <span class="hljs-number">1e-8</span>)&#123;        <br>		<span class="hljs-type">double</span> m = (l+r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(m * m * m &gt;= n)r = m;       <br>		<span class="hljs-keyword">else</span> l = m;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%1f&quot;</span>,l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="高精度计算-记成所有方法都要去除前导零"><a href="#高精度计算-记成所有方法都要去除前导零" class="headerlink" title="高精度计算(记成所有方法都要去除前导零)"></a>高精度计算(记成所有方法都要去除前导零)</h2><h4 id="加法："><a href="#加法：" class="headerlink" title="加法："></a>加法：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">首先**倒序**将各个数字存到vector里（使用a[i]-<span class="hljs-string">&#x27;0&#x27;</span>）<br>然后对两个序列同时进行处理<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a,vector&lt;<span class="hljs-type">int</span>&gt; b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; r;<br>    <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//对两个序列进行迭代</span><br>    <span class="hljs-keyword">while</span>(i &lt; a.<span class="hljs-built_in">size</span>() || i &lt; b.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">if</span>(i &lt; a.<span class="hljs-built_in">size</span>()) c+=a[i];<br>        <span class="hljs-keyword">if</span>(i &lt; b.<span class="hljs-built_in">size</span>()) c+=b[i];<br>        <span class="hljs-comment">//结果位</span><br>        r.<span class="hljs-built_in">push_back</span>(c%<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">//值进位</span><br>        c = c/<span class="hljs-number">10</span>;i++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(c) r.<span class="hljs-built_in">push_back</span>(c);<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="减法："><a href="#减法：" class="headerlink" title="减法："></a>减法：</h4><p>减法我觉得有一些些恶心</p>
<p>首先，减法的操作是用大数减小数，所以首先要判断一个两个数的大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;a, vector&lt;<span class="hljs-type">int</span>&gt; b)</span></span>&#123;<br>    <span class="hljs-comment">//如果a和b的size不同，返回长的</span><br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>() != b.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() &gt;= b.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//从大位到小位判断，返回大的</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(a[i] != b[i])<span class="hljs-keyword">return</span> a[i] &gt; b[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后进行减法操作，操作如下：</p>
<p>1、设置一个t存储当前的借位，默认为0；    </p>
<p>2、对两个序列a,b进行操作，注意借位</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">a-t-b,然后(t+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>判断是否借位<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; a.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-comment">//a大于b</span><br>        <span class="hljs-comment">//减去借位</span><br>        t = a[i] - t;<br>    	<span class="hljs-comment">//如果b还有，则减b</span><br>        <span class="hljs-keyword">if</span>(i &lt; b.<span class="hljs-built_in">size</span>()) t -= b[i];<br>    	<span class="hljs-comment">//加上借位</span><br>        r.<span class="hljs-built_in">push_back</span>((t+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>);<br>    	<span class="hljs-comment">//判断是否借位</span><br>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>3、去除前导0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(r.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; r.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) r.<span class="hljs-built_in">pop_back</span>();<br></code></pre></td></tr></table></figure>

<h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><p>乘法的思路相对简单一些：</p>
<p>1、首先读入的值是一个vector和一个int，<strong>vector存高精度数</strong></p>
<p>2、迭代的时候需要多迭代一次，<strong>即从0-size，因为到i&#x3D;&#x3D;size的时候t可能有数字（超过现在的位数）</strong></p>
<p>​	思路：如果i&lt;size，则当前位为(a[i]*b+t)%10，进位为(a[i] * b+t)&#x2F;10；</p>
<p>3、去除前导零</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++">	<span class="hljs-comment">//多迭代一次</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= a.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(i &lt; a.<span class="hljs-built_in">size</span>())&#123;<br>            r.<span class="hljs-built_in">push_back</span>((a[i]*b+t) % <span class="hljs-number">10</span>);<br>            t = (a[i]*b+t)/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            r.<span class="hljs-built_in">push_back</span>(t);<br>            t = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(r.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; r.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>)r.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> r;<br><br><br><span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= a.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">if</span>(i &lt; a.<span class="hljs-built_in">size</span>())&#123;<br>        r.<span class="hljs-built_in">push_back</span>((a[i]*b+t)%<span class="hljs-number">10</span>);<br>        t = (a[i]*b+t)/<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        r.<span class="hljs-built_in">push_back</span>(t);<br>        t = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">while</span>(r.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>&amp;&amp;r.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)r.<span class="hljs-built_in">pop_back</span>();<br></code></pre></td></tr></table></figure>

<h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p>与前面不同，<strong>除法操作是从高位开始的，</strong>所以读入时需要注意从高位开始压入</p>
<p><strong>存余数的话可以使用一个地址变量不断更新</strong></p>
<p>除法的算法如下：</p>
<p>1、获取当前被除数值的大小 t &#x3D; r*10+a[i];</p>
<p>2、获取结果与余数</p>
<p>​	<strong>结果 res.push_back(t &#x2F; b);</strong></p>
<p>​	<strong>余数 r &#x3D; t%b;</strong></p>
<p>使用int &amp;r将余数返回到主函数</p>
<p><strong>3、倒转结果</strong></p>
<p>4、去除前导零</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;r)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; a.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-type">int</span> t = r*<span class="hljs-number">10</span>+a[i];<br>        res.<span class="hljs-built_in">push_back</span>(t/b);<br>        r = t%b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span>(res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>&amp;&amp;res.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>)res.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h4 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h4><p>s[i] &#x3D; a[i] + s[i-1]从1开始</p>
<p><strong>求解[l,r]</strong> ：s[r]-s[l-1]    <strong>&#x2F;&#x2F;注意是l-1</strong></p>
<h4 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h4><p><strong>s[i,j] &#x3D; s[i,j-1]+s[i-1,j] - s[i,j]+a[i,j];</strong></p>
<p>求解[x1,y1] -&gt; [x2,y2] ：s[x2,y2]-s[x1-1,y2]-s[x2,y1-1]+s[x1-1,y1-1]    <strong>&#x2F;&#x2F;注意x1-1,y1-1</strong></p>
<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><h4 id="一维差分：求某一段的和"><a href="#一维差分：求某一段的和" class="headerlink" title="一维差分：求某一段的和"></a>一维差分：求某一段的和</h4><p>a[i] &#x3D; s[i] - s[i-1];</p>
<p>求解在[l,r]范围+c：a[l] +&#x3D; c;a[r-1]-&#x3D;c;</p>
<p><strong>理解：对a[l]的操作在l之后的所有元素都产生影响</strong></p>
<h4 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> w)</span></span>&#123;<br>    a[x1][y1] += w;<br>    a[x2+<span class="hljs-number">1</span>][y1] -= w;<br>    a[x1][y2+<span class="hljs-number">1</span>] -= w;<br>    a[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] += w;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>步骤：</p>
<p>1、输入</p>
<p>2、inv(i,j,i,j,s[i,j]);</p>
<p>3、inv(x1,y1,x2,y2,w);</p>
<p>4、求和：a[i,j] +&#x3D; a[i,j-1]+a[i-1,j]-a[i-1,j-1];</p>
<h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><p>板子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1、注意i,j的起始（从小到大/从大到小）</span><br><span class="hljs-comment">//2、check条件</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a,j = b;i &lt;= n;i++)&#123;<br>    <span class="hljs-comment">//dealing</span><br>    <span class="hljs-keyword">while</span>(c[f[i]] &gt; <span class="hljs-number">1</span>)&#123;<br>        c[f[j]]--;j++;<br>    &#125;<br> 	<span class="hljs-comment">//dealing</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="最长不连续子序列"><a href="#最长不连续子序列" class="headerlink" title="最长不连续子序列"></a>最长不连续子序列</h4><p>快慢指针法：i指向右端点，j指向左端点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>,j = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>    c[f[i]]++;<br>    <span class="hljs-keyword">while</span>(c[f[i]] &gt; <span class="hljs-number">1</span>)&#123;<br>        c[f[j]]--;j++;<br>    &#125;<br>    r = <span class="hljs-built_in">max</span>(r,i-j+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="数组元素的目标和"><a href="#数组元素的目标和" class="headerlink" title="数组元素的目标和"></a>数组元素的目标和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//从大到小</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>,j = m<span class="hljs-number">-1</span>;i &lt;= n;i++)&#123;<br>    <span class="hljs-keyword">while</span>(a[i]+b[j] &gt; x) j--;<br>    <span class="hljs-keyword">if</span>(a[i] + b[j] == x)&#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j;<span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>,j = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>    <span class="hljs-keyword">while</span>(a[i] != b[j] &amp;&amp; j&lt;=m) j++;<br>    <span class="hljs-keyword">if</span>(j &lt;= m) &#123;<br>        r++;j++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><p>理解：<strong>将x,l,r单独压入一个vector，访问时只使用vector中的下标进行访问</strong></p>
<p>如何找到对应index：<strong>使用二分查找</strong></p>
<p>1、排序，模拟数轴</p>
<p>2、去重 all.erase(unique(all.begin(),all.end()),all.end());</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//去重</span><br><span class="hljs-built_in">sort</span>(all.<span class="hljs-built_in">begin</span>(),all.<span class="hljs-built_in">end</span>());<br>all.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(all.<span class="hljs-built_in">begin</span>(),all.<span class="hljs-built_in">end</span>()),all.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure>

<p>3、对原位置的操作换成对二分之后的位置的操作</p>
<p>4、前缀</p>
<h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><p>1、按左边排序</p>
<p>2、两种判断情况：包含与交叉</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//区间合并算法</span><br><span class="hljs-function">vector&lt;PII&gt; <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;a)</span></span>&#123;<br>    vector&lt;PII&gt; res;<br>    <span class="hljs-comment">//首先按照左边的位置进行排序</span><br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">//保证第一个区间能够被正确处理，r&lt;-1e9即可</span><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">-2e9</span>;<span class="hljs-type">int</span> r = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-comment">//针对包含、交叉、错位三种情况进行处理</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:a)&#123;<br>        <span class="hljs-comment">//错位的情况</span><br>        <span class="hljs-keyword">if</span>(r &lt; item.first)&#123;<br>            <span class="hljs-comment">//如果不是第一次</span><br>            <span class="hljs-keyword">if</span>(l != <span class="hljs-number">-2e9</span>)res.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>            l = item.first;<br>            r = item.second;<br>        &#125;<br>        <span class="hljs-comment">//包含与交叉的情况，左边因排序过，l一定是l，r取最大</span><br>        <span class="hljs-keyword">else</span> r = <span class="hljs-built_in">max</span>(r,item.second);<br>    &#125;<br>    <span class="hljs-comment">//处理最后一个区间</span><br>    <span class="hljs-keyword">if</span>(l != <span class="hljs-number">-2e9</span>)res.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>e[idx] &#x3D; b;ne[idx] &#x3D; h[a];h[a] &#x3D; idx++;</p>
<p>删除：ne[k] &#x3D; ne[ne[k]]; </p>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>初始化：r[0] &#x3D; 1;r[1] &#x3D; 0;idx&#x3D;2;</p>
<p>传入左节点地址k和值x</p>
<p>e[idx] &#x3D; x;r[idx] &#x3D; r[k];l[idx] &#x3D; k;l[r[k]] &#x3D; idx;r[k] &#x3D; idx;</p>
<p>删除中间结点k</p>
<p>r[l[k]] &#x3D; r[k];</p>
<p>l[r[k]] &#x3D; l[k];</p>
<p>艾海舟，孙立峰，袁春</p>
<h2 id="模拟线性表"><a href="#模拟线性表" class="headerlink" title="模拟线性表"></a>模拟线性表</h2><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>数组模拟，top指针，从数组高位操作</p>
<h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><p>1、建表</p>
<p>2、建计算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eval</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> c = operators.<span class="hljs-built_in">top</span>();operators.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> b = operant.<span class="hljs-built_in">top</span>();operant.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> a = operant.<span class="hljs-built_in">top</span>();operant.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">switch</span>(c)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> : operant.<span class="hljs-built_in">push</span>(a+b);<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> : operant.<span class="hljs-built_in">push</span>(a-b);<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> : operant.<span class="hljs-built_in">push</span>(a*b);<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> : operant.<span class="hljs-built_in">push</span>(a/b);<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、判断条件</p>
<p>①是数值 ②是左括号 ③是右括号 ④判断是否需要计算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(s[i]))&#123;<br>           <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>           <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(s[i]))&#123;<br>               t = t*<span class="hljs-number">10</span>+s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;i++;<br>           &#125;<br>           i--;operant.<span class="hljs-built_in">push</span>(t);<br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)operators.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>           <span class="hljs-keyword">while</span>(operators.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>               <span class="hljs-built_in">eval</span>();<br>           &#125;<br>           operators.<span class="hljs-built_in">pop</span>();<br>       &#125;<br>       <span class="hljs-keyword">else</span>&#123;<br>           <span class="hljs-comment">//注意这里：要先判断size()条件，每次都是这样，否则可能出现数组越界的问题</span><br>           <span class="hljs-keyword">while</span>(operators.<span class="hljs-built_in">size</span>() &amp;&amp; p[operators.<span class="hljs-built_in">top</span>()] &gt;= p[s[i]]) <span class="hljs-built_in">eval</span>();<br>           operators.<span class="hljs-built_in">push</span>(s[i]);<br>       &#125;<br></code></pre></td></tr></table></figure>

<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>数组模拟，双指针，从数组高位操作push，低位操作pop</p>
<h4 id="单调栈与单调队列"><a href="#单调栈与单调队列" class="headerlink" title="单调栈与单调队列"></a>单调栈与单调队列</h4><p>单调栈：判断栈顶是否大于当前值即可</p>
<h6 id="给定一个长度为-N-的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-−1。"><a href="#给定一个长度为-N-的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-−1。" class="headerlink" title="给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。"></a>给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</h6><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a><em><u>滑动窗口</u></em></h2><p>注意！！！这道题用数组的<strong>单调队列</strong>做</p>
<p>对于<strong>每次操作的算法</strong>：</p>
<p>1、判断fr对应的值是否已经出栈</p>
<p>2、判断栈尾的值是否大于当前值，如果大于则栈尾的值一定不是最小值，出栈</p>
<p>3、将当前值压栈</p>
<p>4、输出栈顶值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">  	<span class="hljs-comment">//初始fr == 0,rr == -1,让第一个数能直接入队</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>        <span class="hljs-comment">//首先判断最左边的点是否在窗口里</span><br>        <span class="hljs-keyword">if</span>(fr &lt;= rr &amp;&amp; q[fr] &lt; i-m+<span class="hljs-number">1</span>) fr++;<br>        <span class="hljs-comment">//其次判断是否大于栈尾，如果小于则压入，否则栈尾的元素一定不会是最小值，</span><br>        <span class="hljs-keyword">while</span>(fr &lt;= rr &amp;&amp; f[q[rr]] &gt;= f[i]) &#123;<br>            rr--;<br>        &#125;<br>        q[++rr] = i;<br>        <span class="hljs-keyword">if</span>(i &gt;= m<span class="hljs-number">-1</span>) cout &lt;&lt; f[q[fr]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> ;<br>    &#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(fr&lt;=rr &amp;&amp; q[fr]&lt;i-m+<span class="hljs-number">1</span>)fr++;<br>    <span class="hljs-keyword">while</span>(fr&lt;=rr &amp;&amp; f[q[rr]]&gt;=f[i]) rr--;<br>    q[++rr] = i;<br>    <span class="hljs-keyword">if</span>(i &gt; m)cout &lt;&lt; f[q[fr]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a><em><u>KMP</u></em></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin &gt;&gt; m &gt;&gt; p+<span class="hljs-number">1</span> &gt;&gt; n &gt;&gt; s+<span class="hljs-number">1</span>;<br><span class="hljs-comment">//这里对p串的匹配从2开始是因为i==1时，i == j+1在开始一定是成立的，但是我们想要的是非平凡子串，ne[1] == 0，所以直接从2开始</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>,j = <span class="hljs-number">0</span>;i &lt;= n;i++)&#123;<br>    <span class="hljs-comment">//当未匹配成功时则使用next向后跳跃</span><br>    <span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-comment">//判断是哪个条件跳出的，如果是i == j+1则匹配成功，j++指到下一个需要处理的位置；如果是j到头则不处理</span><br>    <span class="hljs-keyword">if</span>(p[i] == p[j+<span class="hljs-number">1</span>])j++;<br>    <span class="hljs-comment">//对每个i的位置进行赋值。</span><br>    ne[i] = j;<br>&#125;<br><span class="hljs-comment">//s串与p串的匹配，过程和next数组求解基本一致，不过next数组是p与p的匹配。</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>,j = <span class="hljs-number">0</span>;i &lt;= n;i++)&#123;<br>    <span class="hljs-keyword">while</span>(j &amp;&amp; s[i] != p[j+<span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span>(s[i] == p[j+<span class="hljs-number">1</span>])j++;<br>    <span class="hljs-comment">//判断是否整串完成匹配</span><br>    <span class="hljs-keyword">if</span>(j == m)&#123;<br>        cout &lt;&lt; i-m &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        j = ne[j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>&#x2F;&#x2F;原理：使用一棵树来存储字符串</p>
<p>使用son[N,26]存储树，cnt[N]数组存每个位置的计数，对应不同的字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> cnt[N],son[N][<span class="hljs-number">26</span>],idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;s[i];i++)&#123;<br>        <span class="hljs-comment">//转义</span><br>        <span class="hljs-type">int</span> t = s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-comment">//如果没有创建则创建</span><br>        <span class="hljs-keyword">if</span>(!son[p][t]) son[p][t]=++idx;<br>        <span class="hljs-comment">//下转</span><br>        p = son[p][t];<br>    &#125;<br>    <span class="hljs-comment">//计数增加</span><br>    cnt[p]++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;s[i];i++)&#123;<br>        <span class="hljs-type">int</span> t = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][t]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][t];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;s[i];i++)&#123;<br>        <span class="hljs-type">int</span> t = s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][t])<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][t];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="最大异或对"><a href="#最大异或对" class="headerlink" title="最大异或对"></a>最大异或对</h4><p>原理：下溯的时候溯与当前位相反的数（保证异或最大）</p>
<p>注意：建树的时候从高到低</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>,p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-type">int</span> t = s &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(son[p][!t])&#123;<br>            r += <span class="hljs-number">1</span> &lt;&lt; i;<br>            p = son[p][!t];<br>        &#125;<br>        <span class="hljs-keyword">else</span> p = son[p][t];<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集***"></a>并查集***</h2><p>并查集可以用来进行集合处理</p>
<h4 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a>合并集合</h4><p>1、首先将每个数做成一个集合</p>
<p>2、合并的时候将p[a] &#x3D; b；</p>
<p><strong>三种操作：注意这里找父节点用的是find函数</strong><br>1、集合合并：<strong>p[find[a]] &#x3D; find[b]</strong><br>2、判断是否属于同一个集合：<strong>find[a] &#x3D;&#x3D; find[b]</strong><br>3、找到父节点：<strong>p[a] &#x3D; find(p[a])</strong></p>
<p><strong>并查集操作：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-comment">//如果不是根节点，则一直上溯，上溯到的一定是根节点，然后在这条路上的所有点的父节点都变成根节点（路径压缩）</span><br>    <span class="hljs-keyword">if</span>(p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="连通块中点的数量"><a href="#连通块中点的数量" class="headerlink" title="连通块中点的数量"></a>连通块中点的数量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;C&#x27;</span>)&#123;<br>          cin &gt;&gt; a &gt;&gt; b;<br>          <span class="hljs-comment">//注意这里：需要判定是否相等，否则会重复加</span><br>          <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a) != <span class="hljs-built_in">find</span>(b))&#123;<br>              cnt[<span class="hljs-built_in">find</span>(b)] += cnt[<span class="hljs-built_in">find</span>(a)];<br>              p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);               <br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>          cin &gt;&gt; a &gt;&gt; b;<br>          <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b)) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>          <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;2&#x27;</span>)&#123;<br>          cin &gt;&gt; a;<br>          cout &lt;&lt; cnt[<span class="hljs-built_in">find</span>(a)] &lt;&lt; endl;<br>      &#125;<br></code></pre></td></tr></table></figure>

<h2 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++">    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(op,<span class="hljs-string">&quot;I&quot;</span>))&#123;<br>        <span class="hljs-type">int</span> t;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);<br>        m++;s++;<span class="hljs-comment">//这里的m出错了</span><br>        <span class="hljs-comment">//尾部插入</span><br>        h[s] = t;<br>        hp[s] = m;ph[m] = s;<br>        <span class="hljs-comment">//上处理，重新刷新堆</span><br>        <span class="hljs-built_in">up</span>(s);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(op,<span class="hljs-string">&quot;PM&quot;</span>))&#123;<br>        cout &lt;&lt; h[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(op,<span class="hljs-string">&quot;DM&quot;</span>))&#123;<br>        <span class="hljs-built_in">heap_swap</span>(<span class="hljs-number">1</span>,s);<br>        s--;<span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(x/<span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span> &amp;&amp; h[x/<span class="hljs-number">2</span>] &gt; h[x]) <span class="hljs-built_in">swap</span>(h[x/<span class="hljs-number">2</span>],h[x]);<br>    x /= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> t = x;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*x&lt;=s &amp;&amp; h[<span class="hljs-number">2</span>*x] &lt; h[t]) t = <span class="hljs-number">2</span>*x;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span> &lt;=s&amp;&amp; h[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>] &lt; h[t]) t = <span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(t != x)&#123;<br>        <span class="hljs-comment">//这里使用的是下标，不是h！！！！！！！！！！！！</span><br>        <span class="hljs-built_in">heap_swap</span>(t,x);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="模拟哈希"><a href="#模拟哈希" class="headerlink" title="模拟哈希"></a>模拟哈希</h2><p><strong>拉链法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//求质数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100003</span>;<br><span class="hljs-comment">//开槽</span><br><span class="hljs-type">int</span> h[N],e[N],ne[N],idx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-comment">//转成正数</span><br>	<span class="hljs-type">int</span> k = (x%N+N)%N;<br>	e[idx] = x;<br>	ne[idx] = h[k];<br>	h[k] = idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-type">int</span> k = (x%N+N)%N;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[k];i != <span class="hljs-number">-1</span>;i = ne[i])&#123;<br>		<span class="hljs-keyword">if</span>(e[i] == x) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	注意要把槽设为<span class="hljs-number">-1</span><br>    <span class="hljs-type">int</span> k = (x%N+N)%N;<br>	<span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h4><p><img src="/post/48f084a8/image-20210822154642276.png" srcset="/img/loading.gif" lazyload alt="image-20210822154642276"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//P = 131或13331</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">131</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL; <br><br><span class="hljs-comment">//h[i]:存1~i位置对应的哈希。p[i]:存第i位对应的p值。</span><br><span class="hljs-type">int</span> h[N],p[N];<br><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-comment">//h[r]:1~r;h[l-1]:1~l-1;</span><br>    <span class="hljs-comment">//p[r-l+1]:对齐高位（ABCDE-ABC00 = DE）</span><br>    <span class="hljs-keyword">return</span> h[r] - h[l<span class="hljs-number">-1</span>] * p[r-l+<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">//从h[1]开始存储数字，代表前1个字符的哈希值，h[0]=0;</span><br>	<span class="hljs-comment">//p[0]=1代表开始的时候没有指数增长。</span><br>    h[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>        cin &gt;&gt; str[i];<br>        <span class="hljs-comment">//字符串的高位同样也是哈希的高位</span><br>        <span class="hljs-comment">//h = h*p+str[i]</span><br>        h[i] = h[i<span class="hljs-number">-1</span>] * P + str[i];<br>        <span class="hljs-comment">//p指数增长</span><br>        p[i] = p[i<span class="hljs-number">-1</span>] * P;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> l1,r1,l2,r2;<br>        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(l1,r1) == <span class="hljs-built_in">get</span>(l2,r2)) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="排列数字"><a href="#排列数字" class="headerlink" title="排列数字"></a>排列数字</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//s[N]:存储是否使用，p[N]:按序存储DFS结果</span><br><span class="hljs-type">int</span> n,s[N],p[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(u &gt; n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>            cout &lt;&lt; p[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-number">0</span>)&#123;<br>            s[i] = u;<br>            p[u] = i;<br>            <span class="hljs-built_in">DFS</span>(u+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//恢复现场</span><br>            p[u] = <span class="hljs-number">0</span>;<br>            s[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h3><p>只记迭代每个位置的方法</p>
<p><img src="/post/48f084a8/image-20210822213659047.png" srcset="/img/loading.gif" lazyload alt="image-20210822213659047"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c,<span class="hljs-type">int</span> t)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(c &gt; n)&#123;<br>        c = <span class="hljs-number">1</span>;<br>        r++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(r &gt; n)&#123;<br>        <span class="hljs-keyword">if</span>(t == n)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++)&#123;<br>                    cout &lt;&lt; s[i][j];<br>                &#125;<br>                cout &lt;&lt; endl;<br>            &#125;<br>            cout&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//注意这里先走不放棋子的分支</span><br>    <span class="hljs-comment">//注意！！！！！！！！！！</span><br>    <span class="hljs-built_in">DFS</span>(r,c+<span class="hljs-number">1</span>,t);<br>    <span class="hljs-comment">//判断横竖，对角线次对角线有没有被占</span><br>    <span class="hljs-keyword">if</span>(!row[r] &amp;&amp; !col[c] &amp;&amp; !dg[r+c] &amp;&amp; !udg[c-r+n])&#123;<br>        row[r] = col[c] = dg[r+c] = udg[c-r+n] = <span class="hljs-number">1</span>;<br>        s[r][c] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>        <span class="hljs-built_in">DFS</span>(r,c+<span class="hljs-number">1</span>,t+<span class="hljs-number">1</span>);<br>        row[r] = col[c] = dg[r+c] = udg[c-r+n] = <span class="hljs-number">0</span>;<br>        s[r][c] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>,M = <span class="hljs-number">110</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; MM;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> h[N][M];<br><span class="hljs-comment">//d表示与起点的距离</span><br><span class="hljs-type">int</span> d[N][M];<br><span class="hljs-comment">//偏移数组</span><br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;;<br>queue&lt;MM&gt; q;<br><span class="hljs-comment">//在一个队列里完成层次遍历，直到队列再次为空，队列中先访问的点的距离一定是相对小的</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//首先初始化d，所有点都没有走到</span><br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> d);<br>    <span class="hljs-comment">//从(1,1)开始</span><br>    d[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-comment">//首先判断是否到终点</span><br>        <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>().first;<br>        <span class="hljs-type">int</span> y = q.<span class="hljs-built_in">front</span>().second;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//如果到终点则跳出</span><br>        <span class="hljs-keyword">if</span>(x == n &amp;&amp; y == m)&#123;<br>            cout &lt;&lt; d[n][m];<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//否则按照四周进行移动</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">4</span>;i++)&#123;<br>                <span class="hljs-type">int</span> px = x+dx[i];<br>                <span class="hljs-type">int</span> py = y+dy[i];<br>                <span class="hljs-comment">//判断是否是有效位置</span><br>                <span class="hljs-keyword">if</span>(px &gt; <span class="hljs-number">0</span> &amp;&amp; px &lt;= n &amp;&amp; py &gt; <span class="hljs-number">0</span> &amp;&amp; py &lt;= m &amp;&amp; h[px][py] != <span class="hljs-number">1</span> &amp;&amp; d[px][py]== <span class="hljs-number">-1</span>)&#123;<br>                    d[px][py] = d[x][y]+<span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">push</span>(&#123;px,py&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j++)&#123;<br>            cin &gt;&gt; h[i][j];<br>        &#125;<br>    &#125;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;);<span class="hljs-built_in">BFS</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="八数码"><a href="#八数码" class="headerlink" title="八数码"></a>八数码</h3><p>特征：矩阵移动性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(string s)</span></span>&#123;<br>    string e = <span class="hljs-string">&quot;12345678x&quot;</span>;<br>    <span class="hljs-comment">//入队</span><br>    q.<span class="hljs-built_in">push</span>(s);<br>    <span class="hljs-comment">//从初始串的位置开始</span><br>    d[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//偏移向量</span><br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-comment">//推理</span><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;、<br>        <span class="hljs-comment">//出队</span><br>        string t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//判断当前位置是否已经是结果</span><br>        <span class="hljs-type">int</span> dt = d[t];<br>        <span class="hljs-keyword">if</span>(t == e) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//找到X的位置</span><br>        <span class="hljs-type">int</span> xx = t.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;x&#x27;</span>);<br>        <span class="hljs-comment">//转化为二维坐标</span><br>        <span class="hljs-type">int</span> tx = xx / <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> ty = xx % <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">//推理到四周的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> px = tx + dx[i];<br>            <span class="hljs-type">int</span> py = ty + dy[i];<br>            <span class="hljs-comment">//如果是合法位置</span><br>            <span class="hljs-keyword">if</span>(px &gt;= <span class="hljs-number">0</span> &amp;&amp; px &lt; <span class="hljs-number">3</span> &amp;&amp; py &gt;= <span class="hljs-number">0</span> &amp;&amp; py &lt; <span class="hljs-number">3</span>)&#123;<br>                <span class="hljs-comment">//交换当前位置</span><br>                <span class="hljs-type">int</span> dp = d[t]+<span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">swap</span>(t[px*<span class="hljs-number">3</span>+py],t[xx]);<br>                <span class="hljs-comment">//如果这个情况没有被走过</span><br>                <span class="hljs-keyword">if</span>(!d.<span class="hljs-built_in">count</span>(t))&#123;<br>                    d[t] = dp;<br>                    q.<span class="hljs-built_in">push</span>(t);<br>                &#125;<br>                <span class="hljs-comment">//恢复现场</span><br>                <span class="hljs-built_in">swap</span>(t[px*<span class="hljs-number">3</span>+py],t[xx]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//判断最终情况是否有记录</span><br>    <span class="hljs-keyword">if</span>(d.<span class="hljs-built_in">count</span>(e)) cout &lt;&lt; d[e];<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="树与图的深度优先遍历"><a href="#树与图的深度优先遍历" class="headerlink" title="树与图的深度优先遍历"></a>树与图的深度优先遍历</h2><h3 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h3><p><img src="/post/48f084a8/image-20210823235144263.png" srcset="/img/loading.gif" lazyload alt="image-20210823235144263"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//返回以u为根的子树中节点的个数，包括u节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">//存储删掉某个节点之后，最大的连通子图节点数</span><br>    st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//标记访问过u节点</span><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">1</span>; <span class="hljs-comment">//存储 以u为根的树的节点数, 包括u，如图中的4号节点</span><br>    <span class="hljs-comment">//访问u的每个子节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-comment">//因为每个节点的编号都是不一样的，所以 用编号为下标来标记是否被访问过</span><br>        <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>            <span class="hljs-type">int</span> s = <span class="hljs-built_in">dfs</span>(j);  <span class="hljs-comment">// u节点的单棵子树节点数如图中的size值</span><br>            res = <span class="hljs-built_in">max</span>(res, s); <span class="hljs-comment">// 记录最大联通子图的节点数</span><br>            sum += s; <span class="hljs-comment">//以j为根的树的节点数</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//n-sum 如图中的n-size值，不包括根节点4；</span><br>    res = <span class="hljs-built_in">max</span>(res, n - sum); <span class="hljs-comment">// 选择u节点为重心，最大的连通子图节点数</span><br>    ans = <span class="hljs-built_in">min</span>(res, ans); <span class="hljs-comment">//遍历过的假设重心中，最小的最大联通子图的节点数</span><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="树与图的广度优先遍历"><a href="#树与图的广度优先遍历" class="headerlink" title="树与图的广度优先遍历"></a>树与图的广度优先遍历</h2><h3 id="图中点的层次"><a href="#图中点的层次" class="headerlink" title="图中点的层次"></a>图中点的层次</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> d);<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t];i != <span class="hljs-number">-1</span>;i = ne[i])&#123;<br>            <span class="hljs-keyword">if</span>(d[e[i]] == <span class="hljs-number">-1</span>)&#123;<br>                d[e[i]]=d[t]+<span class="hljs-number">1</span>;<br>                q.<span class="hljs-built_in">push</span>(e[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(t == n)&#123;<br>            cout &lt;&lt; d[t];<span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="图的排序与最短路"><a href="#图的排序与最短路" class="headerlink" title="图的排序与最短路"></a>图的排序与最短路</h2><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p><img src="/post/48f084a8/image-20210824144744931.png" srcset="/img/loading.gif" lazyload alt="image-20210824144744931"></p>
<p>注意：图中可能存在重边和自环</p>
<p>策略：宽搜+入度计算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//先建图，记录入度</span><br><span class="hljs-keyword">while</span>(m--)&#123;<br>    <span class="hljs-type">int</span> a,b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-built_in">add</span>(a,b);<br>    <span class="hljs-comment">//用一个d数组记入度</span><br>    d[b]++;<br>&#125;<br><span class="hljs-comment">//然后从入度为0的点开始进行处理</span><br><span class="hljs-comment">//宽搜</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>   <span class="hljs-comment">//首先找到所有入度为0的点</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>       <span class="hljs-keyword">if</span>(d[i] == <span class="hljs-number">0</span>)q.<span class="hljs-built_in">push</span>(i);<br>   &#125;<br>   <span class="hljs-comment">//宽搜</span><br>   <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>       <span class="hljs-type">int</span> tmp = q.<span class="hljs-built_in">front</span>();<br>       q.<span class="hljs-built_in">pop</span>();count++;<br>       res.<span class="hljs-built_in">push_back</span>(tmp);<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[tmp];i != <span class="hljs-number">-1</span>;i = ne[i])&#123;<br>           <span class="hljs-type">int</span> link = e[i];<br>           d[link]--;<br>           <span class="hljs-keyword">if</span>(d[link] == <span class="hljs-number">0</span>)q.<span class="hljs-built_in">push</span>(link);<br>       &#125;<br>   &#125;<br>   <span class="hljs-comment">//如果所有点都走完了，这个图的拓扑序列有效</span><br>   <span class="hljs-keyword">if</span>(count == n)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/post/48f084a8/image-20210825001507160.png" srcset="/img/loading.gif" lazyload alt="image-20210825001507160"></p>
<h3 id="Dijkstra算法：非负权，有自环重边"><a href="#Dijkstra算法：非负权，有自环重边" class="headerlink" title="Dijkstra算法：非负权，有自环重边"></a>Dijkstra算法：非负权，有自环重边</h3><p>Dijkstra 的整体思路比较清晰<br>即<strong>进行n（n为n的个数）次迭代</strong>去确定<strong>每个点到起点的最小值</strong>，最后输出的终点的即为我们要找的最短路的距离</p>
<p>步骤</p>
<p>迭代n次，每次迭代都找到<strong>一个符合条件的点加入</strong>，确定一个点的最短路的值，符合的条件为：</p>
<p>1、没有被处理过（即没有加入当前的连通分量）</p>
<p>2、距离最短</p>
<p>找到j点之后将use数组置1，然后对于所有和j点相连的点更新最短路。</p>
<p>初始化memset时无限大是0x3f,memset是按字节填充 int 4 个字节，判断的时候所以是0x3f3f3f3f</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//稠密图需要使用邻接矩阵存储图</span><br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-comment">//记录1点与其他点的距离</span><br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-comment">//判断是否使用过</span><br><span class="hljs-type">int</span> use[N];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstr</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    <span class="hljs-built_in">memset</span>(use,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> use);<br>    <span class="hljs-comment">//从1号点开始，所以dist[1] = 0;</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//迭代所有点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>        <span class="hljs-comment">//设置一个t = -1，保证至少有一个点需要用到</span><br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//判断当前点是否是有效点（未被用过的最短距离）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!use[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j])) t = j;<br>        &#125;<br>        <span class="hljs-comment">//使用当前的点</span><br>        use[t] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//更新从当前点到其他点的最小值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(dist[j] &gt; dist[t]+g[t][j])&#123;<br>                dist[j] = dist[t]+g[t][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//如果更新到了n，则现在的n所存的就是最短路值</span><br>    <span class="hljs-keyword">if</span>(dist[n] != <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> dist[n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//默认无穷大，即没有边</span><br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> g);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> a,b,w;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;<br>        <span class="hljs-comment">//注意这里只保存最短边</span><br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b],w);<br>    &#125;<br>    <span class="hljs-type">int</span> r = <span class="hljs-built_in">dijkstr</span>();<br>    cout &lt;&lt; r;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="堆优化Dijkstra"><a href="#堆优化Dijkstra" class="headerlink" title="堆优化Dijkstra"></a>堆优化Dijkstra</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">disj</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> d = t.first;<br>        <span class="hljs-type">int</span> v = t.second;<br>        <span class="hljs-comment">//优先处理的是最短路，所以如果碰到了第二个相同点的距离，则该距离一定是大的，因此直接continue即可。</span><br>        <span class="hljs-keyword">if</span>(use[v])<span class="hljs-keyword">continue</span>;<br>        use[v] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// cout &lt;&lt; d &lt;&lt; &quot;  &quot; &lt;&lt; v &lt;&lt; endl;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[v];i != <span class="hljs-number">-1</span>;i = ne[i])&#123;<br>            <span class="hljs-type">int</span> k = e[i];<br>            <span class="hljs-comment">//重新压入</span><br>            <span class="hljs-keyword">if</span>(dist[k] &gt; d+w[i])&#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;d+w[i],k&#125;);<br>                dist[k] = d+w[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="贝尔曼算法：含负权，有重边自环，图中可能-存在负权回路-。"><a href="#贝尔曼算法：含负权，有重边自环，图中可能-存在负权回路-。" class="headerlink" title="贝尔曼算法：含负权，有重边自环，图中可能 存在负权回路 。"></a>贝尔曼算法：含负权，有重边自环，图中可能 <strong>存在负权回路</strong> 。</h3><p>步骤：</p>
<p>如果限制最短路上只有k条边，则最外层迭代k次，内层迭代m（边数）次，然后对每个边{a,b,w}，判断dist[b] &#x3D; min(dist[b],dist[a]+w)，即松弛操作。</p>
<p>由于在代码中前面的操作可能会影响后面的操作，因此需要先保存上一次的处理结果，即对dist数组进行备份（注意语法）</p>
<p><img src="/post/48f084a8/image-20210824165312352.png" srcset="/img/loading.gif" lazyload alt="image-20210824165312352"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//所有边使用结构体存更方便</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> a,b,w;<br>&#125; e[N];<br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> dist[N],backup[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//首先设置所有点的距离为0x3f(无限大)</span><br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    <span class="hljs-comment">//从1开始</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//因为最多不经过k条边，因此迭代k次</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;<br>        <span class="hljs-comment">//备份，防止出现串联现象,注意这个语法</span><br>        <span class="hljs-built_in">memcpy</span>(backup,dist,<span class="hljs-keyword">sizeof</span> dist);<br>        <span class="hljs-comment">//每次对所有边进行迭代</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; m;j++)&#123;<br>            <span class="hljs-type">int</span> a = e[j].a;<br>            <span class="hljs-type">int</span> b = e[j].b;<br>            <span class="hljs-type">int</span> w = e[j].w;<br>            <span class="hljs-comment">//松弛操作，判断三角不等式</span><br>            dist[b] = <span class="hljs-built_in">min</span>(dist[b],backup[a]+w);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//由于含有负权，因此在处理最短路的时候dist可能会小于0x3f，但是仍然是无限大的值，因此除以2</span><br>    <span class="hljs-keyword">if</span>(dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0x3f</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,w;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;<br>        <span class="hljs-comment">//注意结构体赋值操作</span><br>        e[i] = &#123;a,b,w&#125;;<br>    &#125;<br>    <span class="hljs-type">int</span> r = <span class="hljs-built_in">bellman_ford</span>();<br>    <span class="hljs-keyword">if</span>(r == <span class="hljs-number">0x3f</span>)cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; r;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="spfa算法：含负权，可能存在重边和自环，判断是否有负环"><a href="#spfa算法：含负权，可能存在重边和自环，判断是否有负环" class="headerlink" title="spfa算法：含负权，可能存在重边和自环，判断是否有负环"></a>spfa算法：含负权，可能存在重边和自环，判断是否有负环</h3><h4 id="求最短路"><a href="#求最短路" class="headerlink" title="求最短路"></a>求最短路</h4><p>spfa是根据贝尔曼算法所做的优化，Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，<strong>我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；</strong>因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。</p>
<h5 id="值得注意的是"><a href="#值得注意的是" class="headerlink" title="值得注意的是"></a>值得注意的是</h5><p><strong>1) st数组的作用：</strong>判断当前的点是否已经加入到队列当中了；<strong>已经加入队列的结点就不需要反复的把该点加入到队列中了</strong>，就算此次还是会更新到源点的距离，那只用更新一下数值而不用加入到队列当中。<br><strong>即便不使用st数组最终也没有什么关系</strong>，但是使用的好处在于可以提升效率。</p>
<ol start="2">
<li>SPFA算法看上去和Dijstra算法长得有一些像但是其中的意义还是相差甚远的:</li>
</ol>
<p>Dijkstra算法里使用的是<strong>优先队列保存的是当前未确定最小距离的点</strong>，目的是快速的取出当前到源点距离最小的点；<strong>SPFA算法中使用的是队列(你也可以使用别的数据结构)</strong>,目的只是记录一下当前发生过更新的点。</p>
<ol start="3">
<li><p>⭐️Bellman_ford算法里最后return-1的判断条件写的是dist[n]&gt;0x3f3f3f3f&#x2F;2;而spfa算法写的是dist[n]&#x3D;&#x3D;0x3f3f3f3f;<strong>其原因在于Bellman_ford算法会遍历所有的边，因此不管是不是和源点连通的边它都会得到更新；</strong>但是SPFA算法不一样，它相当于采用了BFS，因此遍历到的结点都是与源点连通的，因此如果你要求的n和源点不连通，它不会得到更新，还是保持的0x3f3f3f3f。</p>
</li>
<li><p>⭐️ Bellman_ford算法<strong>可以存在负权回路，是因为其循环的次数是有限制的</strong>因此最终不会发生死循环；但是SPFA算法不可以，由于用了队列来存储，只要发生了更新就会不断的入队，因此假如有负权回路请你不要用SPFA否则会死循环。</p>
</li>
<li><p>⭐️<strong>求负环一般使用SPFA算法</strong>，方法是用一个cnt数组记录每个点到源点的边数，一个点被更新一次就+1，一旦有点的边数达到了n那就证明存在了负环。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//距离,st存储点是否在队列中，队列每个点只需要存储一个（注意一下）</span><br><span class="hljs-type">int</span> d[N],st[N];<br><span class="hljs-comment">//队列</span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    e[idx] = b;w[idx] = c;ne[idx] = h[a];h[a] = idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//使用宽搜的方法来优化贝尔曼算法,注意初始化是用0x3f初始化</span><br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>    <span class="hljs-comment">//初始化</span><br>    d[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//从1点开始</span><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//当前点入队</span><br>    st[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>        st[t] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//判断t点所连的边是否有更新</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t];i != <span class="hljs-number">-1</span>;i = ne[i])&#123;<br>            <span class="hljs-type">int</span> et = e[i];<br>            <span class="hljs-type">int</span> wt = w[i];<br>            <span class="hljs-comment">//spfa算法认为只有在当前被修改小之后的点才会影响之后连接的点,使其越来越小</span><br>            <span class="hljs-keyword">if</span>(d[et] &gt; d[t]+wt)&#123;<br>                <span class="hljs-comment">//更新距离</span><br>                d[et] = d[t]+wt;<br>                <span class="hljs-comment">//如果当前点没有入队</span><br>                <span class="hljs-keyword">if</span>(!st[et])&#123;<br>                    q.<span class="hljs-built_in">push</span>(et);<br>                    st[et] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(d[n] == <span class="hljs-number">0x3f3f3f3f</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> d[n];<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="求负环（最常用）"><a href="#求负环（最常用）" class="headerlink" title="求负环（最常用）"></a>求负环（最常用）</h4><p>1、初始的时候将所有点入队，因为负权回路可能是从任意一个点开始</p>
<p>2、在更新点的时候设置一个cnt数组存储<strong>x点到虚拟源点最短路的边数</strong>，初始每个点到虚拟源点的距离为0，只要他能再走n步，即cnt[x] &gt;&#x3D; n，则表示该图中一定存在负环，由于从虚拟源点到x至少经过n条边时，则说明图中至少有n + 1个点，表示一定有点是重复使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>    <span class="hljs-comment">//需要设置一个位置开始迭代,因为1是最开始存进去的,所以先初始化d</span><br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//将所有点加入队列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>        q.<span class="hljs-built_in">push</span>(i);st[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>        st[t] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t];i != <span class="hljs-number">-1</span>;i = ne[i])&#123;<br>            <span class="hljs-type">int</span> et = e[i];<br>            <span class="hljs-type">int</span> wt = w[i];<br>            <span class="hljs-keyword">if</span>(d[et] &gt; d[t] + wt)&#123;<br>                d[et] = d[t] + wt;<br>                <span class="hljs-comment">//更新cnt</span><br>                cnt[et] = cnt[t]+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(!st[et])&#123;<br>                    q.<span class="hljs-built_in">push</span>(et);<br>                    st[et] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//抽屉原理判断负环</span><br>            <span class="hljs-keyword">if</span>(cnt[et] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Floyd算法：多源最短路"><a href="#Floyd算法：多源最短路" class="headerlink" title="Floyd算法：多源最短路"></a>Floyd算法：多源最短路</h3><p>三层循环，原理是dp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;a &lt;= n;a++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;b &lt;= n;b++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c = <span class="hljs-number">1</span>;c &lt;= n;c++)&#123;<br>                d[b][c] = <span class="hljs-built_in">min</span>(d[b][c],d[b][a]+d[a][c]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意使用邻接矩阵处理含重边和自环的图时需要进行预处理</p>
<p>重边：d[a,b]  &#x3D;  min(d[a,b],w)</p>
<p>自环（默认自环为0）：d[a,a] &#x3D; 0；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>         <span class="hljs-keyword">if</span>(i == j) d[i][j] = <span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">else</span> d[i][j] = INF;<br> <span class="hljs-keyword">while</span>(m--) &#123;<br>     cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>     d[x][y] = <span class="hljs-built_in">min</span>(d[x][y], z);<br>     <span class="hljs-comment">//注意保存最小的边</span><br> &#125;<br></code></pre></td></tr></table></figure>

<h3 id="图的处理总结"><a href="#图的处理总结" class="headerlink" title="图的处理总结"></a>图的处理总结</h3><p><img src="/post/48f084a8/image-20210825001903536.png" srcset="/img/loading.gif" lazyload alt="image-20210825001903536"></p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h3><p>和dijkstra算法十分像。</p>
<p>联系：Dijkstra算法是更新到起始点的距离，Prim是更新到集合S的距离</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//初始化距离</span><br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>    <span class="hljs-comment">//不妨从1开始</span><br>    <span class="hljs-comment">//注意这里不要st[1],让循环能选到1进行</span><br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//结果</span><br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//找到最近点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t==<span class="hljs-number">-1</span> || d[t] &gt; d[j]))&#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//不同点1:判断是否连通,注意这里需要特判i,防止最开始的时候没有可连通的点</span><br>        <span class="hljs-keyword">if</span>(d[t] == INF) <span class="hljs-keyword">return</span> INF;<br>        r += d[t];<br>        st[t] = <span class="hljs-number">1</span>;      <br>        <span class="hljs-comment">//更新其他点的距离</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++)&#123;<br>            <span class="hljs-comment">//不同点2:距离更新的时候是更新和当前连通子图的距离,不是和虚拟源点的距离</span><br>            d[j] = <span class="hljs-built_in">min</span>(d[j],g[t][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>1、对边按照权值从小到大排序<br>2、迭代所有边，判断是否边的两端连通，如果不连通则将该边加入<br>3、判断条件：所有点已经加入（count）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> p[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a,b,w;<br>&#125;e[N];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Edge&amp; a,<span class="hljs-type">const</span> Edge&amp;b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.w &lt; b.w;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[a]!=a) p[a] = <span class="hljs-built_in">find</span>(p[a]);<br>    <span class="hljs-keyword">return</span> p[a];<br>&#125;<br><br><br><span class="hljs-comment">//初始化并查集</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)p[i] = i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>    <span class="hljs-type">int</span> a,b,w;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;<br>    e[i] = &#123;a,b,w&#125;;<br>&#125;<br><span class="hljs-comment">//1、边排序</span><br><span class="hljs-built_in">sort</span>(e,e+m,cmp);<br><span class="hljs-comment">//2、从小到大判断是否两端连通</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>    <span class="hljs-type">int</span> a = e[i].a;<br>    <span class="hljs-type">int</span> b = e[i].b;<br>    <span class="hljs-type">int</span> w = e[i].w;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a) != <span class="hljs-built_in">find</span>(b))&#123;<br>        p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br>        r+=w;<br>        cnt++;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//3、判断是否是最小生成树</span><br><span class="hljs-keyword">if</span>(cnt == n)cout &lt;&lt; r;<br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br></code></pre></td></tr></table></figure>

<h2 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h2><p><img src="/post/48f084a8/image-20210825124328622.png" srcset="/img/loading.gif" lazyload alt="image-20210825124328622"></p>
<p><img src="/post/48f084a8/image-20210825124536399.png" srcset="/img/loading.gif" lazyload alt="image-20210825124536399"></p>
<p><strong>遍历所有点，对于每个点为起点进行dfs。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> j = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">//保证每个点都能作为起始染色点</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>    <span class="hljs-comment">//如果没有染色</span><br>    <span class="hljs-keyword">if</span>(!color[i])&#123;<br>        <span class="hljs-comment">//如果从i开始染1号点不成功</span><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>)) &#123;<br>            j = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> c)</span></span>&#123;<br>	<span class="hljs-comment">//先染色</span><br>    color[k] = c;<br>    <span class="hljs-comment">//对连接的所有边判断情况是否成立</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[k];i!=<span class="hljs-number">-1</span>;i = ne[i])&#123;<br>        <span class="hljs-comment">//两种情况</span><br>        <span class="hljs-keyword">if</span>(color[e[i]] == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(e[i],<span class="hljs-number">3</span>-c))<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(color[e[i]]==c)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h2 id="匈牙利算法判断二分图的最大匹配"><a href="#匈牙利算法判断二分图的最大匹配" class="headerlink" title="匈牙利算法判断二分图的最大匹配"></a>匈牙利算法判断二分图的最大匹配</h2><p><img src="/post/48f084a8/image-20210825133131114.png" srcset="/img/loading.gif" lazyload alt="image-20210825133131114"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-comment">//st用于判断当前考虑到了哪个点</span><br><span class="hljs-type">int</span> st[N];<br><span class="hljs-comment">//match用于判断当前右边的点是否已有对应</span><br><span class="hljs-type">int</span> match[N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n2;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i] &amp;&amp; g[x][i])&#123;<br>            <span class="hljs-comment">//注意这里</span><br>            <span class="hljs-comment">//st数组用来保证本次匹配过程中，第二个集合中的每个点只被遍历一次，防止死循环。</span><br>            st[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//两种情况：第一种是右边的点空匹配，则匹配该点；第二种是右边的点匹配到的左边的点还有别的点可以匹配，则也可以匹配该点</span><br>            <span class="hljs-keyword">if</span>(!match[i] || <span class="hljs-built_in">find</span>(match[i]))&#123;<br>                match[i] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>或<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>    <span class="hljs-comment">//对a所连接的边进行迭代</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[a];i != <span class="hljs-number">-1</span>;i = ne[i])&#123;<br>        <span class="hljs-type">int</span> et = e[i];<br>        <span class="hljs-keyword">if</span>(!st[et])&#123;<br>            st[et] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(!match[et] || <span class="hljs-built_in">find</span>(match[et]))&#123;<br>                match[et] = a;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="质数求解"><a href="#质数求解" class="headerlink" title="质数求解"></a>质数求解</h2><h3 id="试除法"><a href="#试除法" class="headerlink" title="试除法"></a>试除法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//试除法是对定义的应用</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">            两个条件：</span><br><span class="hljs-comment">            1、m是1，则No</span><br><span class="hljs-comment">            2、m是2，则判断从2到根号n是否有可以整除的数字</span><br><span class="hljs-comment">                原理：若d|n,则(n/d)|n </span><br><span class="hljs-comment">        */</span><br><span class="hljs-keyword">if</span>(m&lt;<span class="hljs-number">2</span>) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-comment">//这里注意一下i &lt;= m/i，只能用这种，i*i&lt;=m有溢出风险，i&lt;=sqrt(m)太慢</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= m/i;i++)&#123;<br>    <span class="hljs-keyword">if</span>(m % i == <span class="hljs-number">0</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>        k=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(k)cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h3 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h3><h4 id="埃式筛法"><a href="#埃式筛法" class="headerlink" title="埃式筛法"></a>埃式筛法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//埃式筛法</span><br>    <span class="hljs-type">int</span> c= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//从2开始筛</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            c++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j &lt;= n;j+=i)&#123;<br>                st[j] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>	<br></code></pre></td></tr></table></figure>

<h4 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//线性筛法:拿质数筛质数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++)&#123;<br>    <span class="hljs-comment">//找到质数</span><br>    <span class="hljs-keyword">if</span>(!st[i])&#123;<br>         <span class="hljs-comment">//假设primes[0]为n最小的质因子,i为最大的因数，</span><br>        <span class="hljs-comment">//易知若primes[i]中i&gt;0,则会进入循环后产生多余的标记</span><br>        p[c++] = i;<br>        st[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//以当前质数为因子，之前的质数为另一个因子，筛数，质数*质数一定是不一样的</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;p[j] &lt;= n/i;j++)&#123;            <br>        <span class="hljs-comment">//标记;primes[j]一定是primes[j]*i的最小质因子</span><br>        st[p[j]*i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//表明primes[j]一定是i的最小质因子,没有必要再遍历,primes要小于等于i的最小质因子</span><br>        <span class="hljs-comment">//这样能保证每个数遍历一遍,而没有重复</span><br>        <span class="hljs-keyword">if</span>(i % p[j] == <span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(!st[i])&#123;<br>        st[i]=<span class="hljs-number">1</span>;<br>        prime[cnt++] =i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;prime[j]&lt;=n/i;j++)&#123;<br>            st[prime[j]*i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i%prime[j])<span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="约数求解"><a href="#约数求解" class="headerlink" title="约数求解"></a>约数求解</h2><h3 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= a/i;i++)&#123;<br>    <span class="hljs-keyword">if</span>(a % i == <span class="hljs-number">0</span>)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span>(i != a/i)v.<span class="hljs-built_in">push_back</span>(a/i);<br>    &#125;<br>&#125;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:v)&#123;<br>    cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="求约数个数"><a href="#求约数个数" class="headerlink" title="求约数个数"></a>求约数个数</h3><p><img src="/post/48f084a8/image-20210825221658353.png" srcset="/img/loading.gif" lazyload alt="image-20210825221658353"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-keyword">while</span>(n--)&#123;<br>     <span class="hljs-type">int</span> a;<br>     cin &gt;&gt; a;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= a/i;i++)&#123;<br>         <span class="hljs-keyword">if</span>(a % i == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//注意这里是取模判断，素数一定会在质数判断的时候被除完</span><br>             <span class="hljs-keyword">while</span>(a % i == <span class="hljs-number">0</span>)&#123;<br>                 m[i]++;<br>                 a/=i;<br>             &#125;<br>         &#125;<br>     &#125;<br>     <span class="hljs-comment">//注意这里</span><br>     <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">1</span>)m[a]++;<br> &#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a:m)&#123;<br>    <span class="hljs-comment">//注意这里是对每个乘数取模，这样才能存到longlong里，其中需要对res*j取模，</span><br>    <span class="hljs-comment">//res *= (a.second + 1) % N;  这样写等于没取模</span><br>    res = (res*(a.second+<span class="hljs-number">1</span>)) % N;<br>&#125;<br>cout &lt;&lt; res;<br></code></pre></td></tr></table></figure>

<h3 id="约数和：秦九韶算法"><a href="#约数和：秦九韶算法" class="headerlink" title="约数和：秦九韶算法"></a>约数和：秦九韶算法</h3><p><img src="/post/48f084a8/image-20210825223455741.png" srcset="/img/loading.gif" lazyload alt="image-20210825223455741"></p>
<h3 id="最大公约数：辗转相除法"><a href="#最大公约数：辗转相除法" class="headerlink" title="最大公约数：辗转相除法"></a>最大公约数：辗转相除法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span>?a:<span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><img src="/post/image-20210825230159042.png" srcset="/img/loading.gif" lazyload alt="image-20210825230159042" style="zoom:50%;">

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(n--)&#123;<br>    <span class="hljs-type">int</span> a;<br>    cin &gt;&gt; a;<br>    <span class="hljs-comment">//注意这里使用long long,防止越界</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> r = a;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= a/i;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a % i == <span class="hljs-number">0</span>)&#123;<br>            r = r*(i<span class="hljs-number">-1</span>)/i;<br>            <span class="hljs-keyword">while</span>(a % i == <span class="hljs-number">0</span>) a/=i;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">1</span>)r = r*(a<span class="hljs-number">-1</span>)/a;<br>    cout &lt;&lt; r &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="筛法求欧拉和"><a href="#筛法求欧拉和" class="headerlink" title="筛法求欧拉和"></a>筛法求欧拉和</h3><p><img src="/post/48f084a8/image-20210826115712665.png" srcset="/img/loading.gif" lazyload alt="image-20210826115712665"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ruler</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">// 首先背线筛的板子</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            p[cnt++] = i;<br>            <span class="hljs-comment">//如果是质数,则1~i-1都是互质的数</span><br>            phi[i] = i<span class="hljs-number">-1</span>;<br>            st[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;p[j] &lt;= n/i;j++)&#123;<br>            st[p[j]*i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//分情况讨论,这里处理的是p[j]*i的欧拉函数</span><br>            <span class="hljs-comment">//如果是i%p[j] == 0,则p[j]*i和i的质因子相同,只需补N值</span><br>            <span class="hljs-keyword">if</span>(i % p[j] == <span class="hljs-number">0</span>)&#123;<br>                phi[p[j]*i] = phi[i]*p[j]; <br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//如果是i%p[j] != 0,则需要在补p[j]的基础上再乘以(p[j]-1/p[j])</span><br>            <span class="hljs-keyword">else</span> phi[p[j]*i] = phi[i]*(p[j]<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++) r+=phi[i];<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><p>快速幂需要注意%p的位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(LL a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> p)</span></span>&#123;<br>    LL r = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-comment">//如果b的二进制表示的第0位为1,则乘上当前的a</span><br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) r = (LL)((r*a)%p);<br>        <span class="hljs-comment">//右移一位</span><br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//更新a,a依次为a^&#123;2^0&#125;,a^&#123;2^1&#125;,a^&#123;2^2&#125;,....,a^&#123;2^logb&#125;</span><br>        a = a*a%p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title="快速幂求逆元"></a>快速幂求逆元</h3><p><img src="/post/48f084a8/image-20210826131138176.png" srcset="/img/loading.gif" lazyload alt="image-20210826131138176"></p>
<p><img src="/post/48f084a8/image-20210826131645258.png" srcset="/img/loading.gif" lazyload alt="image-20210826131645258"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//a = a * b * b^-1 mod p</span><br><span class="hljs-comment">//∴ b *b^-1mod p==1</span><br><span class="hljs-comment">//而由小费马定理得 b^p-1 mod p == 1;</span><br><span class="hljs-comment">//b^-1 == b^p-2;</span><br><span class="hljs-comment">//即求b^p-2 mod p的值，一个快速幂可以解决</span><br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-built_in">qmi</span>(a,p<span class="hljs-number">-2</span>,p) &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p><img src="/post/48f084a8/image-20210826133840327.png" srcset="/img/loading.gif" lazyload alt="image-20210826133840327"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//扩展欧几里得算法在求得gcd的基础上还可以求得一组x,y解</span><br><span class="hljs-comment">//注意这里必须使用地址符</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> &amp;y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!b)&#123;<br>        x=<span class="hljs-number">1</span>;y=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b,a%b,y,x);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        ax + by = by+(a%b)x = d;</span><br><span class="hljs-comment">        ∴ax+by = by+(a-(a/b)*b)x</span><br><span class="hljs-comment">        ax+by = by+ax-(a/b)*bx</span><br><span class="hljs-comment">        ax+by = b(y-(a/b)x)+ax;</span><br><span class="hljs-comment">        ∴x不变,y=y-(a/b)*x;</span><br><span class="hljs-comment">    */</span><br>    y = y - (a/b)*x;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="求线性同余方程"><a href="#求线性同余方程" class="headerlink" title="求线性同余方程"></a>求线性同余方程</h3><p><img src="/post/48f084a8/image-20210826143242611.png" srcset="/img/loading.gif" lazyload alt="image-20210826143242611"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a,b,m,x,y;<br>cin &gt;&gt; a &gt;&gt; b &gt;&gt; m;<br><span class="hljs-comment">//ax 同余 b mod m的对应条件是存在一组x,y使得ax = my+b</span><br><span class="hljs-comment">//转一下得ax+my&#x27; = b，只要b是gcd(a,m)的倍数，就一定存在一组x,y&#x27;=-y使其成立</span><br><span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(a,m,x,y);<br><span class="hljs-keyword">if</span>(b % d != <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//题目说答案是int，所以我们%d输出，但是在mod m之前的乘法运算中，就可能暴int了，所以我们这里拿ll接一下</span><br><br><span class="hljs-comment">//这里真的是把人差点卡死在这儿</span><br><span class="hljs-comment">//因为x的结果是ax+my==d的解，不是等于b的解，所以首先要x *(b/d)将数放回去,因为这里可能爆栈所以拿LL先接一下，方便计算</span><br><span class="hljs-comment">//然后保险起见，用m mod一下即可，根据(a*x) % m = (a * (x % m)) % m，所以保险起见输出为x % m</span><br><span class="hljs-keyword">else</span> cout &lt;&lt; (LL)x *(b/d) % m &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><h3 id="表达整数的奇怪方式"><a href="#表达整数的奇怪方式" class="headerlink" title="表达整数的奇怪方式"></a>表达整数的奇怪方式</h3><p><img src="/post/48f084a8/image-20210829182612966.png" srcset="/img/loading.gif" lazyload alt="image-20210829182612966"><img src="/post/48f084a8/image-20210829182619920.png" srcset="/img/loading.gif" lazyload alt="image-20210829182619920"></p>
<p><img src="/post/48f084a8/image-20210829182632294.png" srcset="/img/loading.gif" lazyload alt="image-20210829182632294"></p>
<p><img src="/post/48f084a8/image-20210829182641612.png" srcset="/img/loading.gif" lazyload alt="image-20210829182641612"></p>
<p><img src="/post/48f084a8/image-20210829182647238.png" srcset="/img/loading.gif" lazyload alt="image-20210829182647238"></p>
<p><strong>推导过程：</strong></p>
<p><img src="/post/48f084a8/image-20210829184136757.png" srcset="/img/loading.gif" lazyload alt="image-20210829184136757"></p>
<h2 id="组合数问题"><a href="#组合数问题" class="headerlink" title="组合数问题"></a>组合数问题</h2><h3 id="第一种解法：公式法递推"><a href="#第一种解法：公式法递推" class="headerlink" title="第一种解法：公式法递推"></a>第一种解法：公式法递推</h3><p>运用公式：Cb&#x2F;a &#x3D; Cb&#x2F;a-1+Cb-1&#x2F;a-1;</p>
<p>首先将所有的组合数情况用类似DP的方法给计算出来，然后直接哈希对应</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//从0开始</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= <span class="hljs-number">2000</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= i;j++)&#123;<br>            <span class="hljs-comment">//j==0时的情况只有什么都不选这一种情况</span><br>            <span class="hljs-keyword">if</span>(!j) f[i][j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> f[i][j] = (f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+f[i<span class="hljs-number">-1</span>][j])%mod;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="第二种解法：初始化阶乘值"><a href="#第二种解法：初始化阶乘值" class="headerlink" title="第二种解法：初始化阶乘值"></a>第二种解法：初始化阶乘值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//快速幂的板子</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> q)</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(k)&#123;<br>        <span class="hljs-comment">//注意LL</span><br>        <span class="hljs-keyword">if</span>(k&amp;<span class="hljs-number">1</span>) res = (LL)res*a%q;<br>        a = (LL)a*a%q;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-comment">//初始化</span><br>    f[<span class="hljs-number">0</span>] = inf[<span class="hljs-number">0</span> ] =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; N;i++)&#123;<br>        <span class="hljs-comment">//注意LL的问题</span><br>        f[i] = (LL)f[i<span class="hljs-number">-1</span>]*i% mod;<br>        <span class="hljs-comment">//在这里使用到了逆元值，inf[i]代表i % mod的逆元，i %mod的逆元为i^m-2;</span><br>        inf[i] = (LL)inf[i<span class="hljs-number">-1</span>]*<span class="hljs-built_in">qmi</span>(i,mod<span class="hljs-number">-2</span>,mod) % mod;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-comment">//注意LL的问题以及连乘时的两次mod</span><br>        cout &lt;&lt; (LL)f[a] * inf[a-b]%mod * inf[b]%mod &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/post/48f084a8/image-20210829225806186.png" srcset="/img/loading.gif" lazyload alt="image-20210829225806186"></p>
<h3 id="第三种解法：卢卡斯定理"><a href="#第三种解法：卢卡斯定理" class="headerlink" title="第三种解法：卢卡斯定理"></a>第三种解法：卢卡斯定理</h3><img src="/post/image-20210829234753028.png" srcset="/img/loading.gif" lazyload alt="image-20210829234753028" style="zoom:50%;">

<p>如何应用：直接应用公式</p>
<p>首先：注意LL</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">int</span> p;<br><span class="hljs-comment">//快速幂</span><br><span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> p)</span></span>&#123;<br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(k)&#123;<br>        <span class="hljs-keyword">if</span>(k&amp;<span class="hljs-number">1</span>) res = (LL)res*a%p;<br>        a = (LL)a*a%p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">//正常求C的值</span><br><span class="hljs-function">LL <span class="hljs-title">C</span><span class="hljs-params">(LL a,LL b)</span></span>&#123;<br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//上边从a开始，下边从1开始</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>,j = a;i &lt;= b;i++,j--)&#123;<br>        res = (LL)res * j;<br>        <span class="hljs-comment">//注意这里：逆元的成立条件中有一个%p，需要确定好p的取值</span><br>        res = (LL)res * <span class="hljs-built_in">qmi</span>(i,p<span class="hljs-number">-2</span>,p) % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">//卢卡斯定理</span><br><span class="hljs-function">LL <span class="hljs-title">lucas</span><span class="hljs-params">(LL a,LL b)</span></span>&#123;<br>    <span class="hljs-comment">//特例判断</span><br>    <span class="hljs-keyword">if</span>(a &lt; p &amp;&amp; b &lt; p)<span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(a,b);<br>    <span class="hljs-comment">//否则使用lucas定理开始降维</span><br>    <span class="hljs-comment">//注意公式的适用条件中有一个同余</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span> (LL)<span class="hljs-built_in">C</span>(a%p,b%p) * <span class="hljs-built_in">lucas</span>(a/p,b/p) % p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        LL a,b;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>        cout &lt;&lt; <span class="hljs-built_in">lucas</span>(a,b) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="第四种解法：高精度乘法-质数分解抵消"><a href="#第四种解法：高精度乘法-质数分解抵消" class="headerlink" title="第四种解法：高精度乘法+质数分解抵消"></a>第四种解法：高精度乘法+质数分解抵消</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5010</span>;<br><span class="hljs-type">int</span> prime[N],cnt;<br><span class="hljs-type">int</span> sum[N],st[N];<br><span class="hljs-comment">//线性筛法求质数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= a;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])prime[cnt++] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;prime[j] &lt;= a/i;j++)&#123;<br>            st[prime[j]*i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(i % prime[j]==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//得到a!中的p质因子的个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> p)</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(a)&#123;<br>        res+=a/p;<br>        a/=p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">//高精度乘法</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; a.<span class="hljs-built_in">size</span>();i++)&#123;<br>        t += a[i]*b;<br>        res.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(t)&#123;<br>        res.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-comment">// if(t) res.push_back(t);</span><br>    <span class="hljs-keyword">while</span>(res.<span class="hljs-built_in">size</span>() &amp;&amp; res.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) res.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a,b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-comment">//对最大值求质数</span><br>    <span class="hljs-built_in">get_prime</span>(a);<br>    <span class="hljs-comment">//对所有质数求结果中应该有的数量,其中大部分质数的个数都被抵消掉，这里是本算法的核心优化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; cnt;i++)&#123;<br>        sum[i] = <span class="hljs-built_in">get</span>(a,prime[i])-<span class="hljs-built_in">get</span>(a-b,prime[i])-<span class="hljs-built_in">get</span>(b,prime[i]);<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-comment">//初始化</span><br>    ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//对所有质数求结果</span><br>    <span class="hljs-comment">//迭代所有质数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; cnt;i++)&#123;<br>        <span class="hljs-comment">//迭代所有个数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; sum[i];j++)&#123;<br>            ans = <span class="hljs-built_in">mul</span>(ans,prime[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//输出</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = ans.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>        cout &lt;&lt; ans[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="满足条件的01序列"><a href="#满足条件的01序列" class="headerlink" title="满足条件的01序列"></a>满足条件的01序列</h3><p><img src="/post/48f084a8/image-20210831151233385.png" srcset="/img/loading.gif" lazyload alt="image-20210831151233385"></p>
<p><img src="/post/48f084a8/image-20210831151327608.png" srcset="/img/loading.gif" lazyload alt="image-20210831151327608"></p>
<p>红色线是高压红线。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-comment">//注意这里开大！！！</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200010</span>,mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>LL f[N],inf[N];<br><span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> q)</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(k)&#123;<br>        <span class="hljs-keyword">if</span>(k&amp;<span class="hljs-number">1</span>) res = (LL)res*a%q;<br>        a = (LL)a*a%q;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    f[<span class="hljs-number">0</span>] = inf[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; N; i++)&#123;<br>        f[i] = (LL)f[i<span class="hljs-number">-1</span>]*i%mod;<br>        inf[i] = (LL)inf[i<span class="hljs-number">-1</span>]*<span class="hljs-built_in">qmi</span>(i,mod<span class="hljs-number">-2</span>,mod)%mod;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> res = (LL)f[<span class="hljs-number">2</span> * n]*inf[n] % mod * inf[n] % mod * <span class="hljs-built_in">qmi</span>(n + <span class="hljs-number">1</span>, mod - <span class="hljs-number">2</span>,mod) % mod;<br>        cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p><img src="/post/48f084a8/image-20210831202929031.png" srcset="/img/loading.gif" lazyload alt="image-20210831202929031"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//用位运算表示选那几个数字，如果是奇数个则加，如果是偶数个即减。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>,M = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> n,m,f[M];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>        cin &gt;&gt; f[i];<br>    &#125;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//位运算迭代</span><br>    <span class="hljs-comment">//枚举从1 到 1111...(m个1)的每一个集合状态, (至少选中一个集合)</span><br>    <span class="hljs-comment">//从1开始枚举， 枚举到 2^m-1</span><br>    <span class="hljs-comment">//一共有2^m-1项（除了一个都不选之外</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-number">1</span> &lt;&lt; m;i++)&#123;<br>        <span class="hljs-comment">//质数乘积</span><br>        LL t = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//位的数量</span><br>        <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; m;j++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;&gt;j&amp;<span class="hljs-number">1</span>)&#123;<br>				<span class="hljs-comment">//乘积大于n, 则n/t = 0, 跳出这轮循环，可加可不加</span><br>                <span class="hljs-comment">//当前质数的乘积就已经&gt;n了， 直接跳出即可 </span><br>                <span class="hljs-comment">//注意这里需要放到LL</span><br>                <span class="hljs-keyword">if</span>((LL)t*f[j] &gt; n)&#123;<br>                    t = <span class="hljs-number">-1</span>;<span class="hljs-keyword">break</span>;<br>                &#125;<br>                s++;t*= f[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//1~n中能被p整除的个数：n/p下取整</span><br>        <span class="hljs-keyword">if</span>(t != <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(s%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) res += n/t;<br>            <span class="hljs-keyword">else</span> res -= n/t; <br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><h3 id="公平组合游戏"><a href="#公平组合游戏" class="headerlink" title="公平组合游戏"></a>公平组合游戏</h3><p><img src="/post/48f084a8/image-20210831213559881.png" srcset="/img/loading.gif" lazyload alt="image-20210831213559881"></p>
<p><img src="/post/48f084a8/image-20210831222636790.png" srcset="/img/loading.gif" lazyload alt="image-20210831222636790"></p>
<p><img src="/post/48f084a8/image-20210831221029922.png" srcset="/img/loading.gif" lazyload alt="image-20210831221029922"></p>
<p><img src="/post/48f084a8/image-20210831221147080.png" srcset="/img/loading.gif" lazyload alt="image-20210831221147080"></p>
<p><img src="/post/48f084a8/image-20210831221131911.png" srcset="/img/loading.gif" lazyload alt="image-20210831221131911"></p>
<h3 id="台阶NIM问题"><a href="#台阶NIM问题" class="headerlink" title="台阶NIM问题"></a>台阶NIM问题</h3><p><img src="/post/48f084a8/image-20210831230715516.png" srcset="/img/loading.gif" lazyload alt="image-20210831230715516"></p>
<p><strong>解：保证奇数点的数量保持一致不变，这样我们一定可以及时走下去</strong></p>
<p><img src="/post/48f084a8/image-20210831230647515.png" srcset="/img/loading.gif" lazyload alt="image-20210831230647515"></p>
<img src="/post/image-20210831230625539.png" srcset="/img/loading.gif" lazyload alt="image-20210831230625539" style="zoom: 50%;">

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(n--)&#123;<br>    <span class="hljs-type">int</span> a;cin &gt;&gt; a;<br>    <span class="hljs-keyword">if</span>(cnt&amp;<span class="hljs-number">1</span>)res ^= a;<br>    cnt++;<br>&#125;<br><span class="hljs-keyword">if</span>(res) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span>;<br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="集合NIM问题"><a href="#集合NIM问题" class="headerlink" title="集合NIM问题"></a>集合NIM问题</h3><p><img src="/post/48f084a8/image-20210831234405143.png" srcset="/img/loading.gif" lazyload alt="image-20210831234405143"></p>
<p><strong>SG函数：到不了的自然数最小值+1</strong></p>
<img src="/post/image-20210901000015149.png" srcset="/img/loading.gif" lazyload alt="image-20210901000015149" style="zoom: 33%;">

<p>SG(x) &#x3D; 0的话，其对应点无法走到终点，因为没有一条数字下降的路。</p>
<p>SG(x) !&#x3D; 0的话，一定能找到一条路，其路可以指向终点SG(0)</p>
<p>多个图的处理：SG(x1)^SG(x2)^…^SG(xn) &#x3D; 0必败，!&#x3D;0必胜，其中x1,x2,…,xn是每个图的起点</p>
<p><strong>1.Mex运算:</strong><br>设S表示一个非负整数集合.定义mex(S)为求出不属于集合S的最小非负整数运算,即:<br>mes(S)&#x3D;min{x};<br>例如:S&#x3D;{0,1,2,4},那么mes(S)&#x3D;3;</p>
<p><strong>2.SG函数</strong><br>在有向图游戏中,对于每个节点x,设从x出发共有k条有向边,分别到达节点y1,y2,····yk,定义SG(x)的后记节点y1,y2,····<br>yk的SG函数值构成的集合在执行mex运算的结果,即:<br>SG(x)&#x3D;mex({SG(y1),SG(y2)····SG(yk)})<br>特别地,整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值,即 SG(G)&#x3D;SG(s).</p>
<p><strong>3.有向图游戏的和</strong><br>设G1，G2,····,Gm是m个有向图游戏.定义有向图游戏G,他的行动规则是任选某个有向图游戏Gi,并在Gi上行动一步.G被称为有向图游戏G1,G2,·····,Gm的和.<br>有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数的异或和,即:<br>SG(G)&#x3D;SG(G1)xorSG(G2)xor···xor SG(Gm)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-comment">//记忆化搜索</span><br>    <span class="hljs-keyword">if</span>(f[x] != <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> f[x];<br>    set&lt;<span class="hljs-type">int</span>&gt; S;<br>    <span class="hljs-comment">//对所有可能连接到的情况进行迭代，如果x&gt;s[i]，则存入x-s[i]对应的点，加上该分支</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x&gt;=s[i])S.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">sg</span>(x-s[i]));<br>    &#125;<br>    <span class="hljs-comment">//判断所有分支的最大值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;;i++)&#123;<br>        <span class="hljs-comment">//找到最大值赋值</span><br>        <span class="hljs-keyword">if</span>(!S.<span class="hljs-built_in">count</span>(i))<span class="hljs-keyword">return</span> f[x] = i;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(f[x]!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> f[x];<br>    set&lt;<span class="hljs-type">int</span>&gt; S;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x&gt;=s[i])S.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">sg</span>(x-s[i]));<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">count</span>(i))<span class="hljs-keyword">return</span> f[x]=i;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)cin &gt;&gt; s[i];<br>    cin &gt;&gt; k;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> f);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;<br>        <span class="hljs-type">int</span> m;cin &gt;&gt; m;<br>        res^=<span class="hljs-built_in">sg</span>(m);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(res) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="拆分NIM游戏"><a href="#拆分NIM游戏" class="headerlink" title="拆分NIM游戏"></a>拆分NIM游戏</h3><p><img src="/post/48f084a8/image-20210901135552976.png" srcset="/img/loading.gif" lazyload alt="image-20210901135552976"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[x]!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> f[x];<br>    set&lt;<span class="hljs-type">int</span>&gt; S;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; x;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= i;j++)&#123;<br>            S.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">sg</span>(i)^<span class="hljs-built_in">sg</span>(j));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!S.<span class="hljs-built_in">count</span>(i)) <span class="hljs-keyword">return</span> f[x] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img src="/post/48f084a8/image-20210826144543958.png" srcset="/img/loading.gif" lazyload alt="image-20210826144543958"></p>
<h3 id="01背包：每个物品只有一件"><a href="#01背包：每个物品只有一件" class="headerlink" title="01背包：每个物品只有一件"></a>01背包：每个物品只有一件</h3><p><img src="/post/48f084a8/image-20210826144432994.png" srcset="/img/loading.gif" lazyload alt="image-20210826144432994"></p>
<h4 id="二维解法"><a href="#二维解法" class="headerlink" title="二维解法"></a>二维解法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">int</span> w[N],v[N];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= m;j++)&#123;<br>        <span class="hljs-comment">//放物品,如果当前的容量够放得下当前物品</span><br>        <span class="hljs-keyword">if</span>(j &gt;= v[i])&#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i<span class="hljs-number">-1</span>][j-v[i]]+w[i]);<br>        &#125;<br>    &#125;<br>&#125;<br>cout &lt;&lt; f[n][m] &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h4 id="一维解法"><a href="#一维解法" class="headerlink" title="一维解法"></a>一维解法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">int</span> w[N],v[N];<br><span class="hljs-comment">//降到一维之后，原有的不选第i个物品就直接随着i的增加而自动迭代到了下一层</span><br><span class="hljs-comment">//但是，如果还是从小到大进行迭代，可能f[i][j]需要f[i-1][j-v[i]]的值，但是f[i-1][j-v[i]]在前面迭代成了f[i][j-v[i]]</span><br><span class="hljs-comment">//所以有数据污染的危险，因此对j需要从大到小处理</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>    <span class="hljs-comment">//这里直接处理到v[i]，即将原有的if条件等价到这里</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m;j &gt;= v[i];j--)&#123;<br>        f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//因为我们一直算的是max值，所以推到m的时候的结果一定是全局最优解</span><br>cout &lt;&lt; f[m] &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h3 id="完全背包：不规定物品件数"><a href="#完全背包：不规定物品件数" class="headerlink" title="完全背包：不规定物品件数"></a>完全背包：不规定物品件数</h3><p><img src="/post/48f084a8/image-20210826150626209.png" srcset="/img/loading.gif" lazyload alt="image-20210826150626209"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    01背包的转移方程 f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i])</span><br><span class="hljs-comment">    完全背包中选择第i件物品的推导</span><br><span class="hljs-comment">    f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i],f[i-1][j-2v[i]]+2w[i]+...)</span><br><span class="hljs-comment">    减一个v</span><br><span class="hljs-comment">    f[i][j-v[i]] = max(f[i-1][j-v[i]],f[i-1][j-2v[i]]+w[i],f[i-1][j-3v[i]]+2w[i]+...)</span><br><span class="hljs-comment">    所以</span><br><span class="hljs-comment">    完全背包转移方程 f[i][j] = max(f[i-1][j],f[i][j-v[i]]+w[i])</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    所以01背包和完全背包的区别在于选择i时的更新是从i-1更新还是从i更新</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    所以01背包从后往前遍历，防止i-1 --&gt; i</span><br><span class="hljs-comment">    而完全背包正需要将i-1 --&gt; i，所以从前向后遍历</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>    <span class="hljs-comment">//从v[i]开始</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[i];j &lt;= m;j++)&#123;<br>        f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>两个代码其实只有一句不同（注意下标）</p>
<p><code>f[i][j] = max(f[i][j],f[i-1][j-v[i]]+w[i]);//01背包</code></p>
<p><code>f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i]);//完全背包问题</code></p>
<h3 id="多重背包：规定每个物品的件数"><a href="#多重背包：规定每个物品的件数" class="headerlink" title="多重背包：规定每个物品的件数"></a>多重背包：规定每个物品的件数</h3><p><img src="/post/48f084a8/image-20210826150820966.png" srcset="/img/loading.gif" lazyload alt="image-20210826150820966"></p>
<p>在01背包的基础上加入一套循环，每次加入k件物品，进行判断（O(N3))</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>    <span class="hljs-type">int</span> v,w,s;<br>    cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;<br>    <span class="hljs-comment">//注意这里需要从大到小进行处理</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m;j &gt;= v;j--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k &lt;= s;k++)&#123;<br>            <span class="hljs-keyword">if</span>(j &gt;= k*v) f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-k*v]+k*w);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>优化：<strong>使用快速幂的思路，重新创造一个物品列表</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Good</span>&#123;<br>    <span class="hljs-type">int</span> v,w;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;Good&gt; g;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>        <span class="hljs-type">int</span> v,w,s;<br>        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;<br>        <span class="hljs-comment">//注意每次对g进行清理</span><br>        g.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-comment">//重新创建一个序列，按照二进制的规则存储</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;s &gt;= j;j*=<span class="hljs-number">2</span>)&#123;<br>            g.<span class="hljs-built_in">push_back</span>(&#123;j*v,j*w&#125;);<br>            s-=j;<br>        &#125;<br>        <span class="hljs-comment">//如果s有剩余，也存进去，防止漏掉物品</span><br>        <span class="hljs-keyword">if</span>(s)g.<span class="hljs-built_in">push_back</span>(&#123;s*v,s*w&#125;);<br>        <span class="hljs-comment">//对当前的新物品列表进行01背包</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a:g)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m;j &gt;= a.v;j--)&#123;<br>                f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-a.v]+a.w);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="分组背包：每个组内01背包"><a href="#分组背包：每个组内01背包" class="headerlink" title="分组背包：每个组内01背包"></a>分组背包：每个组内01背包</h3><p><img src="/post/48f084a8/image-20210826160014477.png" srcset="/img/loading.gif" lazyload alt="image-20210826160014477"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin&gt;&gt;s[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;s[i];j++)<br>        cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;s[i];k++)<br>            <span class="hljs-keyword">if</span>(v[i][k]&lt;=j) f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-v[i][k]]+w[i][k]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="线性DP问题"><a href="#线性DP问题" class="headerlink" title="线性DP问题"></a>线性DP问题</h2><p>线性DP问题一般都涉及到位置计算。</p>
<h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><p><img src="/post/48f084a8/image-20210826165855069.png" srcset="/img/loading.gif" lazyload alt="image-20210826165855069"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//从下向上可以解决分支问题</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>;i &gt; <span class="hljs-number">0</span>;i--)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= i;j++)&#123;<br>        f[i][j] = <span class="hljs-built_in">max</span>(f[i+<span class="hljs-number">1</span>][j],f[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>])+f[i][j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="最长上升子序列：使用二分进行优化"><a href="#最长上升子序列：使用二分进行优化" class="headerlink" title="最长上升子序列：使用二分进行优化"></a>最长上升子序列：使用二分进行优化</h3><img src="/post/image-20210826172152769.png" srcset="/img/loading.gif" lazyload alt="image-20210826172152769" style="zoom:50%;">

<p>原理：</p>
<p>题解中最难理解的地方在于栈中序列虽然递增，但是每个元素在原串中对应的位置其实可能是乱的，那为什么这个栈还能用于计算最长子序列长度？<br>实际上这个栈【不用于记录最终的最长子序列】，<strong>而是【以stk[i]结尾的子串长度最长为i】</strong>或者说<strong>【长度为i的递增子串中，末尾元素最小的是stk[i]】</strong>。理解了这个问题以后就知道为什么新进来的元素要不就在末尾增加，要不就替代第一个大于等于它元素的位置。<br>这里的【替换】就蕴含了一个贪心的思想，对于同样长度的子串，我当然希望它的末端越小越好，这样以后我也有更多机会拓展。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> f[N],n;<br><span class="hljs-type">int</span> g[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)cin &gt;&gt; f[i];<br>    <span class="hljs-comment">//替换思想体现了贪心，我们希望序列每个位置的数都更小</span><br>    g[<span class="hljs-number">1</span>] = f[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++)&#123;<br>        <span class="hljs-comment">//如果当前序列的最大值小于f[n]，则加入数组</span><br>        <span class="hljs-keyword">if</span>(g[t] &lt; f[i])&#123;<br>            g[t+<span class="hljs-number">1</span>] = f[i];<br>            t++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//找到第一个大于等于f[n]的值</span><br>            <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>,r = t;<br>            <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>                <span class="hljs-type">int</span> m = (l+r)/<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span>(g[m] &gt;= f[i]) r = m;<br>                <span class="hljs-keyword">else</span> l = m+<span class="hljs-number">1</span>;<br>            &#125;<br>            g[l] = f[i];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; t &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    分析</span><br><span class="hljs-comment">    状态表示 f[i][j]</span><br><span class="hljs-comment">            定义：表示a的前i个字符和b的前j个字符所组成的所有子序列</span><br><span class="hljs-comment">            属性：长度最大值</span><br><span class="hljs-comment">    状态计算：看成集合</span><br><span class="hljs-comment">            这个状态下产生不同的原因是是否有a[i]或者b[j]</span><br><span class="hljs-comment">            f[i][j]的计算针对于a[i],b[j]可以由以下几个部分组成：</span><br><span class="hljs-comment">                1、有a[i]和b[j]     if(a[i] == b[j]) f[i][j] = f[i-1][j-1]+1;</span><br><span class="hljs-comment">                2、没有a[i]或b[j]    f[i][j] = f[i-1][j-1]</span><br><span class="hljs-comment">                3、有a[i]没b[j]   f[i][j-1]表示的是a的前i个字符和b的前j-1个字符的子序列最大值，虽然不一定包含b[j],但包含了当前情况。而且f[i][j-1]是不超过集合f[i][j]的，即f[i][j-1]集合的最大值包含当前情况且没有出界。所以可以用f[i][j-1]代替本情况</span><br><span class="hljs-comment">                4、有b[i]没a[i]   同上,用f[i-1][j]代替本情况</span><br><span class="hljs-comment">                </span><br><span class="hljs-comment">*/</span> <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j++)&#123;<br>        <span class="hljs-comment">//分情况讨论</span><br>        <span class="hljs-keyword">if</span>(a[i]==b[j]) f[i][j] = f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i][j<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br>cout &lt;&lt; f[n][m] &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h3 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    1、状态表示：f[i][j]</span><br><span class="hljs-comment">        定义：从a[1..i]到b[1..j]的操作</span><br><span class="hljs-comment">        属性：求操作次数最小值</span><br><span class="hljs-comment">    2、状态计算：（从最后的操作出发）</span><br><span class="hljs-comment">        对于一个f[i][j]，求解的情况有三种（注意这里，对a的删除理论上和对b的增加一致，所以只考虑对a的操作）</span><br><span class="hljs-comment">        a.删除   f[i][j] = f[i-1][j]+1 （从a的后面删除一个字符）</span><br><span class="hljs-comment">        b.增加   f[i][j] = f[i][j-1]+1 （在a的后面增加一个字符）</span><br><span class="hljs-comment">            最后一步是增加：若最后一步是增加，为了使a[1 ~ i] = b[1 ~ j]那最后一步增加的一定是b[j]。</span><br><span class="hljs-comment">            那么f[i][j]就可以看成是，首先将a[1 ~ i]转化成b[1 ~ j - 1]，这时候所操作的步骤数为f[i][j - 1]，下一步在b[j - 1]后面添加一个b[j]，那么f[i][j] = f[i][j - 1] + 1。</span><br><span class="hljs-comment">            也就是说，我们的转化过程为：a[1 ~ i] -&gt; b[1 ~ j - 1] -&gt; b[1 ~ j]，</span><br><span class="hljs-comment">            f[i][j]的意义是将a[1 ~ i]转化为b[1 ~ j]的步骤数，不能理解为直接在a[i]后面添加一个数，这是一个动态的变化的过程。</span><br><span class="hljs-comment">        c.修改   f[i][j] = if(a[i] == b[j])f[i-1][j-1]（不用改） else f[i-1][j-1]+1（加上修改操作）</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//边界条件</span><br><span class="hljs-comment">//判断一下是否需要边界条件</span><br><span class="hljs-comment">//只进行增加操作</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= m;i++)f[<span class="hljs-number">0</span>][i] = i;<br><span class="hljs-comment">//只进行删除操作</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++)f[i][<span class="hljs-number">0</span>] = i;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j++)&#123;<br>        <span class="hljs-comment">//四种情况</span><br>        <span class="hljs-comment">//增加与删除</span><br>        f[i][j] = <span class="hljs-built_in">min</span>(f[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>,f[i][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//不动与替换</span><br>        f[i][j] = <span class="hljs-built_in">min</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+(a[i]!=b[j]));<br>    &#125;<br>&#125;<br>cout &lt;&lt; f[n][m];<br></code></pre></td></tr></table></figure>

<h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><p><img src="/post/48f084a8/image-20210827130138656.png" srcset="/img/loading.gif" lazyload alt="image-20210827130138656"></p>
<p><img src="/post/48f084a8/image-20210827121556326.png" srcset="/img/loading.gif" lazyload alt="image-20210827121556326"></p>
<p><img src="/post/48f084a8/image-20210827123510128.png" srcset="/img/loading.gif" lazyload alt="image-20210827123510128"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">310</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    1、集合表示f[i][j]</span><br><span class="hljs-comment">        定义：从第i个石子到第j个石子的所有合并情况</span><br><span class="hljs-comment">        属性：代价最小值</span><br><span class="hljs-comment">    2、集合计算</span><br><span class="hljs-comment">        对于一个从i到j的集合，可以从[i,i],[i+1,j] / [i,i+1],[i+2,j] / ... / [i,k],[k+1,j] / ... / [i,j-1],[j,j]这样来枚举</span><br><span class="hljs-comment">        即对每一个可能的合并情况进行处理</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> s[N],a[N],f[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)s[i] = a[i]+s[i<span class="hljs-number">-1</span>];<br><br>    <span class="hljs-comment">//长度为1时不需要合并，为0</span><br>    <span class="hljs-comment">// for(int i = 1;i &lt;= n;i++)f[i][i] = a[i];</span><br>    <span class="hljs-comment">//区间dp的第一步一般为对区间长度进行枚举</span><br>    <span class="hljs-comment">//O(n^3)的时间复杂度</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>;len &lt;= n;len++)&#123;		<span class="hljs-comment">//区间枚举</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i + len<span class="hljs-number">-1</span> &lt;= n;i++)&#123;	<span class="hljs-comment">//起点迭代</span><br>            <span class="hljs-type">int</span> j = i+len<span class="hljs-number">-1</span>;				<span class="hljs-comment">//计算终点</span><br>            f[i][j] = <span class="hljs-number">1e7</span>;<br>            <span class="hljs-comment">//转移方程						</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = i;k &lt;= j<span class="hljs-number">-1</span>;k++)&#123;	<span class="hljs-comment">//状态转移</span><br>                f[i][j] = <span class="hljs-built_in">min</span>(f[i][j],f[i][k]+f[k+<span class="hljs-number">1</span>][j]);<br>            &#125;<br>            f[i][j] += s[j]-s[i<span class="hljs-number">-1</span>];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[<span class="hljs-number">1</span>][n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="计数DP"><a href="#计数DP" class="headerlink" title="计数DP"></a>计数DP</h2><p><img src="/post/48f084a8/image-20210827130855450.png" srcset="/img/loading.gif" lazyload alt="image-20210827130855450"></p>
<img src="/post/image-20210827150150578.png" srcset="/img/loading.gif" lazyload alt="image-20210827150150578" style="zoom: 50%;">

<p><img src="/post/48f084a8/image-20210827150207137.png" srcset="/img/loading.gif" lazyload alt="image-20210827150207137"></p>
<h2 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h2><h3 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h3><h2 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h2><h3 id="蒙特卡罗的梦想"><a href="#蒙特卡罗的梦想" class="headerlink" title="蒙特卡罗的梦想"></a>蒙特卡罗的梦想</h3><p><img src="/post/48f084a8/image-20210827151843247.png" srcset="/img/loading.gif" lazyload alt="image-20210827151843247"></p>
<p><img src="/post/48f084a8/image-20210827164455255.png" srcset="/img/loading.gif" lazyload alt="image-20210827164455255"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">12</span>, M = <span class="hljs-number">1</span>&lt;&lt; N;  <br><span class="hljs-type">long</span> <span class="hljs-type">long</span> f[N][M] ;<span class="hljs-comment">// 第一维表示列， 第二维表示所有可能的状态</span><br><span class="hljs-type">bool</span> st[M];  <span class="hljs-comment">//存储每种状态是否有奇数个连续的0，如果奇数个0是无效状态，如果是偶数个零置为true。</span><br><span class="hljs-comment">//vector&lt;int &gt; state[M];  //二维数组记录合法的状态</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">state</span>(M);  <span class="hljs-comment">//两种写法等价:二维数组</span><br><span class="hljs-type">int</span> m , n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m, n||m)&#123; <span class="hljs-comment">//读入n和m，并且不是两个0即合法输入就继续读入</span><br>        <span class="hljs-comment">//第一部分：预处理1</span><br>        <span class="hljs-comment">//对于每种状态，先预处理每列不能有奇数个连续的0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt; <span class="hljs-number">1</span>&lt;&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> cnt =<span class="hljs-number">0</span> ;<span class="hljs-comment">//记录连续的0的个数</span><br>            <span class="hljs-type">bool</span> isValid = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 某种状态没有奇数个连续的0则标记为true</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123; <span class="hljs-comment">//遍历这一列，从上到下</span><br>                 <span class="hljs-keyword">if</span>( i&gt;&gt;j &amp;<span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">//i&gt;&gt;j位运算，表示i（i在此处是一种状态）的二进制数的第j位； &amp;1为判断该位是否为1，如果为1进入if</span><br>                    <span class="hljs-keyword">if</span>(cnt &amp;<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//这一位为1，看前面连续的0的个数，如果是奇数（cnt &amp;1为真）则该状态不合法</span><br>                        isValid =<span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;<br>                    &#125; <br>                    cnt=<span class="hljs-number">0</span>; <span class="hljs-comment">// 既然该位是1，并且前面不是奇数个0（经过上面的if判断），计数器清零。//其实清不清零没有影响</span><br>                 &#125;<br>                 <span class="hljs-keyword">else</span> cnt++; <span class="hljs-comment">//否则的话该位还是0，则统计连续0的计数器++。</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(cnt &amp;<span class="hljs-number">1</span>)  isValid =<span class="hljs-literal">false</span>; <span class="hljs-comment">//最下面的那一段判断一下连续的0的个数</span><br>            st[i]  = isValid; <span class="hljs-comment">//状态i是否有奇数个连续的0的情况,输入到数组st中</span><br>        &#125;<br><br>        <span class="hljs-comment">//第二部分：预处理2</span><br>        <span class="hljs-comment">// 经过上面每种状态 连续0的判断，已经筛掉一些状态。</span><br>        <span class="hljs-comment">//下面来看进一步的判断：看第i-2列伸出来的和第i-1列伸出去的是否冲突</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt; <span class="hljs-number">1</span>&lt;&lt;n;j++)&#123; <span class="hljs-comment">//对于第i列的所有状态</span><br>            state[j].<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//清空上次操作遗留的状态，防止影响本次状态。</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt; <span class="hljs-number">1</span>&lt;&lt;n;k++)&#123; <span class="hljs-comment">//对于第i-1列所有状态</span><br>                <span class="hljs-keyword">if</span>((j&amp;k )==<span class="hljs-number">0</span> &amp;&amp; st[ j| k] ) <span class="hljs-comment">// 第i-2列伸出来的 和第i-1列伸出来的不冲突(不在同一行) </span><br>                <span class="hljs-comment">//解释一下st[j | k] </span><br>                <span class="hljs-comment">//已经知道st[]数组表示的是这一列没有连续奇数个0的情况，</span><br>                <span class="hljs-comment">//我们要考虑的是第i-1列（第i-1列是这里的主体）中从第i-2列横插过来的，还要考虑自己这一列（i-1列）横插到第i列的</span><br>                <span class="hljs-comment">//比如 第i-2列插过来的是k=10101，第i-1列插出去到第i列的是 j =01000，</span><br>                <span class="hljs-comment">//那么合在第i-1列，到底有多少个1呢？自然想到的就是这两个操作共同的结果：两个状态或。 j | k = 01000 | 10101 = 11101</span><br>                <span class="hljs-comment">//这个 j|k 就是当前 第i-1列的到底有几个1，即哪几行是横着放格子的</span><br>                    state[j].<span class="hljs-built_in">push_back</span>(k);  <span class="hljs-comment">//二维数组state[j]表示第j行， </span><br>                    <span class="hljs-comment">//j表示 第i列“真正”可行的状态，如果第i-1列的状态k和j不冲突则压入state数组中的第j行。</span><br>                    <span class="hljs-comment">//“真正”可行是指：既没有前后两列伸进伸出的冲突；又没有连续奇数个0。</span><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-comment">//第三部分：dp开始</span><br>        <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> f);  <span class="hljs-comment">//全部初始化为0，因为是连续读入，这里是一个清空操作。类似上面的state[j].clear()</span><br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span> ;<span class="hljs-comment">// 这里需要回忆状态表示的定义，按定义这里是：前第-1列都摆好，且从-1列到第0列伸出来的状态为0的方案数。</span><br>        <span class="hljs-comment">//首先，这里没有-1列，最少也是0列。其次，没有伸出来，即没有横着摆的。即这里第0列只有竖着摆这1种状态。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;= m;i++)&#123; <span class="hljs-comment">//遍历每一列:第i列合法范围是(0~m-1列)</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt; <span class="hljs-number">1</span>&lt;&lt;n; j++)&#123;  <span class="hljs-comment">//遍历当前列（第i列）所有状态j</span><br>                <span class="hljs-keyword">for</span>( <span class="hljs-keyword">auto</span> k : state[j])    <span class="hljs-comment">// 遍历第i-1列的状态k，如果“真正”可行，就转移</span><br>                    f[i][j] += f[i<span class="hljs-number">-1</span>][k];    <span class="hljs-comment">// 当前列的方案数就等于之前的第i-1列所有状态k的累加。</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最后答案是什么呢？</span><br>        <span class="hljs-comment">//f[m][0]表示 前m-1列都处理完，并且第m-1列没有伸出来的所有方案数。</span><br>        <span class="hljs-comment">//即整个棋盘处理完的方案数</span><br>        cout&lt;&lt; f[m][<span class="hljs-number">0</span>]&lt;&lt;endl;<br><br>    &#125;<br>&#125;  <br></code></pre></td></tr></table></figure>

<h3 id="最短哈密顿路径（旅行商问题）"><a href="#最短哈密顿路径（旅行商问题）" class="headerlink" title="最短哈密顿路径（旅行商问题）"></a>最短哈密顿路径（旅行商问题）</h3><p><img src="/post/48f084a8/image-20210828111300203.png" srcset="/img/loading.gif" lazyload alt="image-20210828111300203"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    分析：</span><br><span class="hljs-comment">    状态表示：f[i][j]</span><br><span class="hljs-comment">        定义：在完成i的状态路径之后（i表示走过的点）到达j点的所有路径集合</span><br><span class="hljs-comment">        计算：权重最小值</span><br><span class="hljs-comment">    状态计算：</span><br><span class="hljs-comment">        因为到了j点，所以j点是确定的，不确定的是从哪个点到达的k点</span><br><span class="hljs-comment">        所以转移方程是</span><br><span class="hljs-comment">        f[state][j] =  min(f[state][j],f[state ^ 1&lt;&lt;j][k] + w[k][j])</span><br><span class="hljs-comment">        即我们只需要注意走过哪些点、走到哪个点，共两种情况</span><br><span class="hljs-comment">        因为如果走的是相同的点，所形成的所有路径中一定有一个最小值，而且其他路径都可以用其代替</span><br><span class="hljs-comment">        注意：初始化是从第0个点开始，state用二进制表示当前所在的点，所以f[1][0]=0;代表从0开始</span><br><span class="hljs-comment">*/</span><br><br><br></code></pre></td></tr></table></figure>

<p><img src="/post/48f084a8/image-20210828104558147.png" srcset="/img/loading.gif" lazyload alt="image-20210828104558147"></p>
<p><img src="/image-20210915004217354.png" srcset="/img/loading.gif" lazyload alt="image-20210915004217354"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//DP</span><br><span class="hljs-comment">//初始化每个点都没有连</span><br><span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> g);<br><span class="hljs-comment">//从1点开始</span><br>g[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//确定当前状态，即哪些点被用过</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">1</span>&lt;&lt;n;i++)&#123;<br>    <span class="hljs-comment">//当前停在了哪个点上</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)&#123;			<span class="hljs-comment">//确定了所用点和所停点，即可确定序列</span><br>        <span class="hljs-comment">//如果当前状态包含j，即j有效</span><br>        <span class="hljs-keyword">if</span>(i&gt;&gt;j &amp; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//j确定，迭代之前一个的k状态，判断更新最小距离</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k &lt; n;k++)&#123;<br>                <span class="hljs-comment">//如果k状态也包含</span><br>                <span class="hljs-keyword">if</span>(i&gt;&gt;k &amp; <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-comment">//更新最小值g[i-(1&lt;&lt;j)][k]，将j去除之后的k结果</span><br>                    g[i][j] = <span class="hljs-built_in">min</span>(g[i][j],g[i-(<span class="hljs-number">1</span>&lt;&lt;j)][k]+f[k][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出</span><br>cout &lt;&lt; g[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure>

<h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><h3 id="没有上司的酒会"><a href="#没有上司的酒会" class="headerlink" title="没有上司的酒会"></a>没有上司的酒会</h3><p><img src="/post/48f084a8/image-20210828111946980.png" srcset="/img/loading.gif" lazyload alt="image-20210828111946980"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">//如果选择n点，加上happy值</span><br>    f[n][<span class="hljs-number">1</span>] = happy[n];<br>    <span class="hljs-comment">//对其上司进行处理</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[n];i != <span class="hljs-number">-1</span>;i = ne[i])&#123;<br>        <span class="hljs-type">int</span> down = e[i];<br>        <span class="hljs-built_in">dfs</span>(down);<br>        <span class="hljs-comment">//如果不选n点，down可能选可能不选</span><br>        f[n][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(f[down][<span class="hljs-number">1</span>],f[down][<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">//如果选n点，down点一定不会被选</span><br>        f[n][<span class="hljs-number">1</span>] += f[down][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)cin &gt;&gt; happy[i];<br>    <span class="hljs-comment">//建树</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(b,a);<br>        upper[a] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//找根节点</span><br>    <span class="hljs-type">int</span> root = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(upper[root])root++;<br>    <span class="hljs-comment">//从根节点进行迭代</span><br>    <span class="hljs-built_in">dfs</span>(root);<br>    cout &lt;&lt; <span class="hljs-built_in">max</span>(f[root][<span class="hljs-number">0</span>],f[root][<span class="hljs-number">1</span>]) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>记忆化搜索一般跟着dfs一起使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[x][y]) <span class="hljs-keyword">return</span> f[x][y];<span class="hljs-comment">//如果已经记录过了，就不用再算了 </span><br>    f[x][y]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> xx=x+dx[i];<span class="hljs-comment">//到下一个点 </span><br>        <span class="hljs-type">int</span> yy=y+dy[i];<br>        <span class="hljs-keyword">if</span>(xx&gt;=<span class="hljs-number">1</span>&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=<span class="hljs-number">1</span>&amp;&amp;yy&lt;=m&amp;&amp;h[x][y]&gt;h[xx][yy])<span class="hljs-comment">//点在范围内，且此点高度，比刚才的点矮就滑过去 </span><br>        &#123;<br>            f[x][y]=<span class="hljs-built_in">max</span>(f[x][y],<span class="hljs-built_in">dp</span>(xx,yy)+<span class="hljs-number">1</span>);<span class="hljs-comment">//比较大小，取出最大的 </span><br>        &#125;                                       <span class="hljs-comment">//+1，是因为如果到从两个点的滑雪距离一样的话，再滑一步，就滑到x，y这个点了，所以+1 </span><br>    &#125;<br>    <span class="hljs-keyword">return</span> f[x][y];<span class="hljs-comment">//返回最终值 </span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="划分数"><a href="#划分数" class="headerlink" title="划分数"></a>划分数</h2><p><img src="/image-20210914152204058.png" srcset="/img/loading.gif" lazyload alt="image-20210914152204058"></p>
<img src="/post/image-20210914152628226.png" srcset="/img/loading.gif" lazyload alt="image-20210914152628226" style="zoom: 67%;">

<p><img src="/image-20210914152609245.png" srcset="/img/loading.gif" lazyload alt="image-20210914152609245"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">12</span>;<br>LL f[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    LL a,b;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; a &gt;&gt; b)&#123;<br><span class="hljs-comment">//         cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt;endl;</span><br>        <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> f);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= a; ++i)<br>            f[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= b; ++j)<br>            f[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= a;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= b;j++)&#123;<br>                <span class="hljs-keyword">if</span>(i &gt;= j)f[i][j] = f[i][j<span class="hljs-number">-1</span>]+f[i-j][j];<br>                <span class="hljs-keyword">else</span> f[i][j] = f[i][i];<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; f[a][b] &lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><h3 id="区间选点（最大不相交区间数）"><a href="#区间选点（最大不相交区间数）" class="headerlink" title="区间选点（最大不相交区间数）"></a>区间选点（最大不相交区间数）</h3><p><img src="/post/48f084a8/image-20210828221114654.png" srcset="/img/loading.gif" lazyload alt="image-20210828221114654"></p>
<p><strong>右端点排序。</strong>每次优先找最右端点，如果当前最右点小于下一个区间的最左点，则前面所有区间的最右边和下一区间的最左边没有相交，即多一个新的区间。·</p>
<p><img src="/post/48f084a8/image-20210828220535066.png" srcset="/img/loading.gif" lazyload alt="image-20210828220535066"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        e[i]=&#123;l,r&#125;;<br>    &#125;<br><span class="hljs-comment">//按右端点排序</span><br>    <span class="hljs-built_in">sort</span>(e,e+n,cmp);<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//更新端点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>        <span class="hljs-type">int</span> tl = e[i].l;<br>        <span class="hljs-keyword">if</span>(r&lt;tl)&#123;<br>            sum++;<br>            r = e[i].r;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; sum &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h3 id="区间分组（教室安排问题）"><a href="#区间分组（教室安排问题）" class="headerlink" title="区间分组（教室安排问题）"></a>区间分组（教室安排问题）</h3><p><strong>左端点排序。</strong>找到最靠左的右端点，如果最靠左的max_r &lt; l，代表存在一个组可以放入这个区间。</p>
<p><img src="/post/48f084a8/image-20210829133130091.png" srcset="/img/loading.gif" lazyload alt="image-20210829133130091"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(p,p+n,cmp);<br><span class="hljs-comment">//我们的小根堆始终保证所有组中的最小的右端点为根节点</span><br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>    <span class="hljs-type">int</span> l = p[i].l;<br>    <span class="hljs-comment">//如果还没有分组，或者当前最小右端点还要大于区间左端点</span><br>    <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">empty</span>() || l &lt;= q.<span class="hljs-built_in">top</span>())&#123;<br>        <span class="hljs-comment">//所以需要新开一个分组</span><br>        q.<span class="hljs-built_in">push</span>(p[i].r);r++;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//否则存在一个组可以放入</span><br>        <span class="hljs-comment">//弹出之前的最小右端点并放入当前的右端点</span><br>        q.<span class="hljs-built_in">pop</span>();q.<span class="hljs-built_in">push</span>(p[i].r);<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-comment">//左端点排序</span><br><span class="hljs-built_in">sort</span>(p,p+n,cmp);<br>pri q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>    <span class="hljs-comment">//如果满足条件</span><br>    <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">empty</span>()||p[i].l &lt;= q.<span class="hljs-built_in">top</span>())&#123;<br>        q.<span class="hljs-built_in">push</span>(p[i].r);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        q.<span class="hljs-built_in">pop</span>();q.<span class="hljs-built_in">push</span>(p[i].r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="区间覆盖"><a href="#区间覆盖" class="headerlink" title="区间覆盖"></a>区间覆盖</h3><p><img src="/post/48f084a8/image-20210829135504450.png" srcset="/img/loading.gif" lazyload alt="image-20210829135504450"></p>
<p><strong>左端点排序</strong>，在左端点小于s的情况下优先找右端点最大的区间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>    <span class="hljs-comment">//注意初始化</span><br>    <span class="hljs-type">int</span> j = i,r = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-comment">//判断当前的l小于st的每个区间，找到右端最远的区间</span><br>    <span class="hljs-keyword">while</span>(j &lt; n &amp;&amp; p[j].l &lt;= s)&#123;<br>        <span class="hljs-comment">//如果小于，则将最右端更新成最远的那个点</span><br>        r = <span class="hljs-built_in">max</span>(r,p[j].r);<br>        j++;<br>    &#125;<br>    <span class="hljs-comment">//首先判断是否有断点</span><br>    <span class="hljs-keyword">if</span>(r &lt; s) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">//否则当前满足区域，将该区域加到res中</span><br>    res++;<br>    <span class="hljs-comment">//其次判断是否完成搜索</span><br>    <span class="hljs-keyword">if</span>(r &gt;= t)&#123;<br>        sc = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果没完成，则将s更新，继续遍历</span><br>    s = r;<br>    <span class="hljs-comment">//注意倒退操作</span><br>    i = j<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(sc) cout &lt;&lt; res;<br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>区间选点问题：<strong>右排序</strong>，优先选择最右点</p>
<p>区间分组问题：<strong>左排序</strong>，如果最小分组的max_r都大于当前区间的l，则代表区间与所有分组有冲突，新开一组</p>
<p>区间覆盖问题：<strong>左排序</strong>，如果l&lt;s，则找到其符合条件区间的最右端点并更新成s，注意判断断点和结束点</p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p><img src="/post/48f084a8/image-20210829160917625.png" srcset="/img/loading.gif" lazyload alt="image-20210829160917625"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//小根堆</span><br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br><span class="hljs-keyword">while</span>(n--)&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    q.<span class="hljs-built_in">push</span>(t);<br>&#125;<br><span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-type">int</span> a = q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> b = q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> c = a+b;r+=c;<br>    q.<span class="hljs-built_in">push</span>(c);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a>排序不等式</h2><img src="/post/image-20210829163822491.png" srcset="/img/loading.gif" lazyload alt="image-20210829163822491" style="zoom: 50%;">

<p><img src="/post/48f084a8/image-20210829163918358.png" srcset="/img/loading.gif" lazyload alt="image-20210829163918358"></p>
<h2 id="绝对值不等式"><a href="#绝对值不等式" class="headerlink" title="绝对值不等式"></a>绝对值不等式</h2><h3 id="货仓选址"><a href="#货仓选址" class="headerlink" title="货仓选址"></a>货仓选址</h3><p><img src="/post/48f084a8/image-20210829164000459.png" srcset="/img/loading.gif" lazyload alt="image-20210829164000459"></p>
<p>​	<strong>优先向中间建货仓</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)cin &gt;&gt; f[i];<br>    <span class="hljs-built_in">sort</span>(f,f+n);<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> m = n/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>        r += <span class="hljs-built_in">abs</span>(f[i]-f[m]);<br>    &#125;<br>    cout &lt;&lt; r;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h2><img src="/post/image-20210829165354551.png" srcset="/img/loading.gif" lazyload alt="image-20210829165354551" style="zoom: 50%;">

<h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> months[<span class="hljs-number">2</span>][<span class="hljs-number">13</span>] = &#123;<br>        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>,<span class="hljs-number">31</span>,<span class="hljs-number">29</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;,<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isLeap</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (y%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;y%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span>)||y%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> years[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">365</span>,<span class="hljs-number">366</span>&#125;;<br>string s[<span class="hljs-number">10</span>]=&#123;<span class="hljs-string">&quot;Friday&quot;</span>,<span class="hljs-string">&quot;Saturday&quot;</span>,<span class="hljs-string">&quot;Sunday&quot;</span>,<span class="hljs-string">&quot;Monday&quot;</span>,<span class="hljs-string">&quot;Tuesday&quot;</span>,<span class="hljs-string">&quot;Wednesday&quot;</span>,<span class="hljs-string">&quot;Thursday&quot;</span>&#125;;<br><br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="category-chain-item">学习笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%9C%BA%E8%AF%95/">#机试</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>机试复习</div>
      <div>http://paopao0226.site/post/48f084a8.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ywj226</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年8月18日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2023年9月23日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/post/bf1e6b0b.html" title="开学机试速通">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">开学机试速通</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/post/95c4b274.html" title="保研经验贴">
                        <span class="hidden-mobile">保研经验贴</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'boxy-light';
      var dark = 'photon-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'paopao0226/Commit-Utterance');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', '✨');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  




  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a>   Thanks for Watching 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="/js/code-unfold.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://paopao0226.site/categories/学习笔记/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 学习笔记 (41)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://paopao0226.site/categories/日常tips/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 救命教程 (15)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://paopao0226.site/categories/学生工作记录/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱‍👓 学生工作 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://paopao0226.site/categories/实验室工作/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 打工记录 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://paopao0226.site/categories/经验分享/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 浅谈经验 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="http://paopao0226.site/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #ebedf0;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #fdcdec}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":225,"height":350},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
